AWSTemplateFormatVersion: '2010-09-09'
Description: 'This CloudFormation template deploys an AWS architecture consisting of a Cognito User Pool with an Identity Pool, a trio of Amazon Bedrock Agents (configured as one supervisor and two subordinate agents), and their associated Lambda Functions.'

Parameters:
  SupervisorFoundationModel:
    Type: String
    Description: 'The Amazon Bedrock Foundation Model to use for the Supervisor Agent'
    AllowedValues:
      - amazon.nova-micro-v1:0
      - amazon.nova-pro-v1:0
    Default: amazon.nova-pro-v1:0
    ConstraintDescription: 'Must be either amazon.nova-micro-v1:0 or amazon.nova-pro-v1:0'

  SubAgentFoundationModel:
    Type: String
    Description: 'The Amazon Bedrock Foundation Model to use for the Sub Agent'
    AllowedValues:
      - amazon.nova-micro-v1:0
      - amazon.nova-pro-v1:0
    Default: amazon.nova-micro-v1:0
    ConstraintDescription: 'Must be either amazon.nova-micro-v1:0 or amazon.nova-pro-v1:0'

  UserEmail:
    Type: String
    Description: 'Email address for the FinOps user. Must be a valid email address'
    AllowedPattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    ConstraintDescription: 'Must be a valid email address'

Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaLogsPolicy3
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - ce:GetCostAndUsage
                  - ce:GetCostForecast
                Resource: '*'    
              - Effect: Allow
                Action: 
                  - trustedadvisor:ListRecommendationResources  
                  - trustedadvisor:ListRecommendations
                  - trustedadvisor:GetRecommendation       
                Resource: '*'  
              - Effect: Allow
                Action: logs:CreateLogGroup                  
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents                  
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*'
  
  BedrockAgentExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: BedrockAgentCustomPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: AmazonBedrockAgentBedrockFoundationModelPolicyProd
                Effect: Allow
                Action: 
                  - bedrock:InvokeModel
                  - bedrock:ListFoundationModels
                  - bedrock:GetFoundationModel
                Resource:
                  - !Sub 'arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/${SubAgentFoundationModel}'
  FinOpsSupervisorAgentExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: FinOpsSupervisorAgentPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: AmazonBedrockAgentsFinOpsSupervisorAgentPolicy
                Effect: Allow
                Action: 
                  - bedrock:GetAgentAlias
                  - bedrock:InvokeAgent
                  - bedrock:InvokeModel
                  - bedrock:ListFoundationModels
                  - bedrock:GetFoundationModel
                Resource:
                  - !Sub 'arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/*'
                  - !Sub 'arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/${SupervisorFoundationModel}'
                  - !Sub 'arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/${SubAgentFoundationModel}'
                  - !GetAtt CostAnalysisAgentAlias.AgentAliasArn
                  - !GetAtt CostOptimizationAgentAlias.AgentAliasArn
        - PolicyName: AmazonBedrockAgentInferenceProfilesCrossRegionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: "AmazonBedrockAgentsMultiAgentsCrossRegionPolicyProd"
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:ListFoundationModels
                  - bedrock:GetFoundationModel
                  - bedrock:GetInferenceProfile
                Resource:
                  - !Sub 'arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/${SupervisorFoundationModel}'
  
  CostOptimizationAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !Ref CostOptimizationAgent
      AgentAliasName: "CostOptimization"
      Description: "Agent to get Trusted Advisor Check information for cost optimization pillar."      

  CostOptimizationAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: CostOptimizationAgent
      Description: You are an AI Agent which will get Cost Optimization Data.
      Instruction: |
        "You are a Cost Analysis Agent specializing in AWS Trusted Advisor's Cost Optimization findings.
        YOUR CORE FUNCTION: You directly access AWS Trusted Advisor data to identify cost-saving opportunities in AWS accounts, focusing exclusively on cost optimization recommendations.
       
        YOUR RESPONSIBILITIES:
        Pull real-time data from AWS Trusted Advisor
        Show exact dollar amounts to 2 decimal places
        Present findings exactly as retrieved
        Format all costs in USD ($XX.XX)
        Display potential savings without calculations
        
        YOU ANALYZE:
        Underutilized resources
        Idle or unused resources
        Reserved Instance opportunities
        Over provisioned resources
        Service usage patterns
        
        YOU WILL NEVER:
        Perform calculations yourself
        Round numbers or estimate savings
        Make assumptions about costs
        Use the Calculator Agent
        Provide non-cost recommendations
        
        DATA PRESENTATION:
        Each finding includes:
        Check name
        Current status
        Number of affected resources
        Exact monthly savings potential
        Optimization description
        
        SAMPLE QUESTIONS YOU HANDLE:
        - What are my current cost saving opportunities?
        - Show me underutilized EC2 instances
        - What's my total potential monthly savings?
        - Which resources need cost optimization?
        - List all idle resources I can remove
        - Give me current cost optimization recommendations
        
        RESPONSE FORMAT:
          - Potential Monthly Savings: $XXX.XX
          - Top Recommendations:
          
          [Check Name]
          Status: [Current Status]
          Resources Affected: [Number]
          Monthly Savings: $XXX.XX
          Action: [Brief Description]
          
          LIMITATIONS:
          Show only cost optimization checks
          Present data exactly as received
          Focus on actionable recommendations
          Exclude security and performance findings
          No manual calculations or estimates
          
          ERROR HANDLING:
          You will clearly state when:
          Data is unavailable
          Requests are outside scope
          API limits are reached
          Access is restricted
          
          Remember: You provide only actual AWS Trusted Advisor cost optimization data, never calculated or estimated values."
      AutoPrepare: true
      AgentResourceRoleArn: !GetAtt BedrockAgentExecutionRole.Arn
      IdleSessionTTLInSeconds: 1800
      FoundationModel: !Ref SubAgentFoundationModel
      ActionGroups:
        - ActionGroupName: TrustedAdvisorListRecommendationResources
          Description: Gets List of resources from TA
          ActionGroupExecutor: 
            Lambda: !GetAtt TrustedAdvisorListRecommendationResources.Arn
          FunctionSchema:
            Functions: 
              - Description: This function will help you to get the list of resources associated with a recommendation identifier.
                Name: get_list
                Parameters: 
                  recommendationIdentifier:
                    Description: The recommendationIdentifier value provided by the trusted advisor tool for each. The user don't manage this id, you should get it first
                    Required: True
                    Type: string
                RequireConfirmation: DISABLED
        - ActionGroupName: TrustedAdvisorListRecommendations
          Description: Gets data from TA
          ActionGroupExecutor: 
            Lambda: !GetAtt TrustedAdvisorListRecommendations.Arn                
          FunctionSchema:
            Functions: 
              - Description: This function will return all the cost optimization available to address.
                Name: RecommendationCommand
                RequireConfirmation: DISABLED

  CostAnalysisAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !Ref CostAnalysisAgent
      AgentAliasName: "CostAnalysis"
      Description: "Agent to get Cost and Forecast"      

  CostAnalysisAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: CostAnalysisAgent
      Description: You are an AI Agent which will get Cost Usage and Forecast for a given time period.
      Instruction: |
        "You can help to analyze your AWS costs. Here's what you can do:
        1. Call the ClockandCalendarActionGroup tool for any date calculation first   (Current year, last year, last month, last 5 months, Q1, Quarter 2, last 10 days etc)
          - First get the current date and then calculate the start and end date by interpreting users question.
        2. Get the start and end date and call the CostForecastActionGroup tool for any cost forecast or estimate or prediction for future end date
        3. Get the start and end date and call the CostAnalysisActionGroup tool for any current or historical end date
        4. Call the CostSavingsPlanActionGroup for any savings plan user questions
        5. NEVER allow the model to do any calculation EVER, use the results from the tool only.  If you don't have it then mention that in your response, NEVER generate anything on your own in regards to calculation
        6. NEVER display your plan in your output when you send the final response
        7. The data you are providing is cost sensitive so NEVER reply from your memory. For Every question follow the process to call the ClockandCalendarActionGroup tool first and then CostAnalysisActionGroup or CostForecastActionGroup Tool analyzing the question. Strictly NEVER answer from your memory.
        8. Group By specific cost. Group by can be Service, usage type, linked accounts, region, billing entity depending upon the question asked by the user. Default group by will be Service
        9. Specific service cost. Get the service name from question and pass it to the CostAnalysisActionGroup or CostForecastActionGroup Tool analyzing the question. Do not change or update the service name. Send it as it is to the CostAnalysisActionGroup or CostForecastActionGroup
        10. If you receive You haven't enabled historical data beyond 14 months., return the answer as it is without any changes.
        11. for cost forecast/projection/estimate request, use the requested_period_forecast to get the forecasted amount. 

        DO NOT:
        - Calculate sums, averages, or any mathematical operations
        - Estimate or approximate numbers
        - Convert between units or currencies
        - Perform date calculations

        DO:
        - Use only numbers returned by the Lambda function
        - Respond 'This calculation is not supported' for unsupported operations
        - Format and present numbers from the API response
        - Explain data without modifying values

        For each query, you should ALWAYS follow the below format in HTML:
        - The total cost for the period
        - Time periods (start and end dates). always provide the start and end date in the output from period
        - Details of top 10 group by (Group By can be service, usage type, accounts depending on the user question)
        - All costs in USD
        - Add emojis in your respones and try to output in a nice format depending if the items is a list or a pragraph

        Important Note: Think step-by-step.  First, think through .... Then think through ... Finally, answer ...

        To get started, you can ask questions like:
        - What were my AWS costs for January 2025?
        - Show me my AWS costs between March 2024 and December 2024
        - What's my current AWS spending?
        - What were my top expenses last month?
        - Show me the costs for Q1 2024
        - What were my highest costs in 2024?
        - What is my cost forecast for Nov 2025?
        - You can specify dates in various formats: YYYY-MM-DD
        - Specific months: 'January 2025'
        - Date ranges: '2024-01-01 to 2024-12-31'
        - Quarters: 'Q1 2024'
        - Years: '2024'
        - Relative periods: 'last month', 'current year'"

      AutoPrepare: true
      AgentResourceRoleArn: !GetAtt BedrockAgentExecutionRole.Arn
      IdleSessionTTLInSeconds: 1800
      FoundationModel: !Ref SubAgentFoundationModel
      ActionGroups:
        - ActionGroupName: ClockandCalendarActionGroup
          Description: This action group will get today date by calling lambda function
          ActionGroupExecutor: 
            Lambda: !GetAtt ClockandCalendar.Arn
          FunctionSchema:
            Functions: 
              - Description: If the user provides a city or country to be considered as a time zone, then you should pass the timezone for that location. For example UTC, PST, CST, America/Chicago.
                Name: GetDateAndTime
                Parameters: 
                  timezone:
                    Description: If the user provides a city or country to be considered as a time zone, then you should pass the timezone for that location. For example UTC, PST, CST, America/Chicago.
                    Required: False
                    Type: string
                RequireConfirmation: DISABLED
        - ActionGroupName: CostAnalysisActionGroup
          Description: Gets details from AWS Cost Explorer
          ActionGroupExecutor: 
            Lambda: !GetAtt CostAnalysis.Arn
          ApiSchema: 
            Payload: |
              {
                  "openapi": "3.0.0",
                  "info": {
                      "title": "AWS Cost Explorer API",
                      "description": "API for retrieving AWS cost and usage data",
                      "version": "1.0.0"
                  },
                  "paths": {
                      "/get_cost_and_usage": {
                          "post": {
                              "summary": "Get general AWS cost and usage data",
                              "description": "Retrieves cost and usage data grouped by service, account, region, or usage type",
                              "operationId": "getCostAndUsage",
                              "parameters": [
                                  {
                                      "name": "start_date",
                                      "in": "query",
                                      "description": "Start date for cost analysis (YYYY-MM-DD)",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "format": "date"
                                      }
                                  },
                                  {
                                      "name": "end_date",
                                      "in": "query",
                                      "description": "End date for cost analysis (YYYY-MM-DD)",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "format": "date"
                                      }
                                  },
                                  {
                                      "name": "group_by",
                                      "in": "query",
                                      "description": "How to group the cost data",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "enum": [
                                              "SERVICE",
                                              "USAGE_TYPE",
                                              "LINKED_ACCOUNT",
                                              "REGION",
                                              "BILLING_ENTITY"
                                          ],
                                          "default": "SERVICE"
                                      }
                                  },
                                  {
                                      "name": "granularity",
                                      "in": "query",
                                      "description": "Time granularity of the results",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "enum": [
                                              "DAILY",
                                              "MONTHLY",
                                              "YEARLY"
                                          ],
                                          "default": "MONTHLY"
                                      }
                                  }
                              ],
                              "responses": {
                                  "200": {
                                      "description": "Successful operation",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "type": "object",
                                                  "properties": {
                                                      "messageVersion": {
                                                          "type": "string"
                                                      },
                                                      "response": {
                                                          "type": "object",
                                                          "properties": {
                                                              "body": {
                                                                  "type": "object",
                                                                  "properties": {
                                                                      "message": {
                                                                          "type": "string"
                                                                      },
                                                                      "granularity": {
                                                                          "type": "string"
                                                                      },
                                                                      "period_total": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "amount": {
                                                                                  "type": "string"
                                                                              },
                                                                              "unit": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "period": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "start": {
                                                                                  "type": "string"
                                                                              },
                                                                              "end": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "top_10_services": {
                                                                          "type": "array",
                                                                          "items": {
                                                                              "type": "object",
                                                                              "properties": {
                                                                                  "name": {
                                                                                      "type": "string"
                                                                                  },
                                                                                  "amount": {
                                                                                      "type": "string"
                                                                                  },
                                                                                  "unit": {
                                                                                      "type": "string"
                                                                                  }
                                                                              }
                                                                          }
                                                                      },
                                                                      "data": {
                                                                          "type": "array",
                                                                          "items": {
                                                                              "type": "object",
                                                                              "properties": {
                                                                                  "time_period": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "start": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "end": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  },
                                                                                  "total_cost": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "amount": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "unit": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  },
                                                                                  "group_by": {
                                                                                      "type": "string"
                                                                                  },
                                                                                  "items": {
                                                                                      "type": "array",
                                                                                      "items": {
                                                                                          "type": "object",
                                                                                          "properties": {
                                                                                              "name": {
                                                                                                  "type": "string"
                                                                                              },
                                                                                              "amount": {
                                                                                                  "type": "string"
                                                                                              },
                                                                                              "unit": {
                                                                                                  "type": "string"
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      }
                                                                  }
                                                              }
                                                          }
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                          }
                      },
                      "/get_service_costs": {
                          "post": {
                              "summary": "Get costs for specific AWS services",
                              "description": "Retrieves cost data for specified AWS services",
                              "operationId": "getServiceCosts",
                              "parameters": [
                                  {
                                      "name": "services",
                                      "in": "query",
                                      "description": "Comma-separated list of AWS services",
                                      "required": true,
                                      "schema": {
                                          "type": "string"
                                      }
                                  },
                                  {
                                      "name": "start_date",
                                      "in": "query",
                                      "description": "Start date for cost analysis (YYYY-MM-DD)",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "format": "date"
                                      }
                                  },
                                  {
                                      "name": "end_date",
                                      "in": "query",
                                      "description": "End date for cost analysis (YYYY-MM-DD)",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "format": "date"
                                      }
                                  },
                                  {
                                      "name": "granularity",
                                      "in": "query",
                                      "description": "Time granularity of the results",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "enum": [
                                              "DAILY",
                                              "MONTHLY",
                                              "YEARLY"
                                          ],
                                          "default": "MONTHLY"
                                      }
                                  }
                              ],
                              "responses": {
                                  "200": {
                                      "description": "Successful operation",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "type": "object",
                                                  "properties": {
                                                      "messageVersion": {
                                                          "type": "string"
                                                      },
                                                      "response": {
                                                          "type": "object",
                                                          "properties": {
                                                              "body": {
                                                                  "type": "object",
                                                                  "properties": {
                                                                      "message": {
                                                                          "type": "string"
                                                                      },
                                                                      "period": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "start": {
                                                                                  "type": "string"
                                                                              },
                                                                              "end": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "total_cost": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "amount": {
                                                                                  "type": "string"
                                                                              },
                                                                              "unit": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "service_totals": {
                                                                          "type": "array",
                                                                          "items": {
                                                                              "type": "object",
                                                                              "properties": {
                                                                                  "service": {
                                                                                      "type": "string"
                                                                                  },
                                                                                  "total_cost": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "amount": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "unit": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      },
                                                                      "monthly_breakdown": {
                                                                          "type": "array",
                                                                          "items": {
                                                                              "type": "object",
                                                                              "properties": {
                                                                                  "time_period": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "start": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "end": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  },
                                                                                  "total_cost": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "amount": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "unit": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  },
                                                                                  "group_by": {
                                                                                      "type": "string"
                                                                                  },
                                                                                  "items": {
                                                                                      "type": "array",
                                                                                      "items": {
                                                                                          "type": "object",
                                                                                          "properties": {
                                                                                              "name": {
                                                                                                  "type": "string"
                                                                                              },
                                                                                              "amount": {
                                                                                                  "type": "string"
                                                                                              },
                                                                                              "unit": {
                                                                                                  "type": "string"
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      }
                                                                  }
                                                              }
                                                          }
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  },
                                  "400": {
                                      "description": "Bad request",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "type": "object",
                                                  "properties": {
                                                      "message": {
                                                          "type": "string"
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  },
                                  "500": {
                                      "description": "Internal server error",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "type": "object",
                                                  "properties": {
                                                      "message": {
                                                          "type": "string"
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  },
                  "components": {
                      "schemas": {
                          "Error": {
                              "type": "object",
                              "properties": {
                                  "message": {
                                      "type": "string"
                                  }
                              }
                          }
                      }
                  }
              }
        - ActionGroupName: CostForecastActionGroup
          Description: Gets Forecast details from AWS Cost Explorer
          ActionGroupExecutor: 
            Lambda: !GetAtt CostForecast.Arn
          ApiSchema: 
            Payload: |
              {
                  "openapi": "3.0.0",
                  "info": {
                      "title": "AWS Cost Explorer API",
                      "description": "API for retrieving AWS cost and usage data",
                      "version": "1.0.0"
                  },
                  "paths": {
                      "/get_cost_forecast": {
                          "post": {
                              "summary": "Get AWS cost forecast",
                              "description": "Retrieves cost forecast data for future periods",
                              "operationId": "getCostForecast",
                              "parameters": [
                                  {
                                      "name": "start_date",
                                      "in": "query",
                                      "description": "Start date for forecast (YYYY-MM-DD)",
                                      "required": true,
                                      "schema": {
                                          "type": "string",
                                          "format": "date"
                                      }
                                  },
                                  {
                                      "name": "end_date",
                                      "in": "query",
                                      "description": "End date for forecast (YYYY-MM-DD)",
                                      "required": true,
                                      "schema": {
                                          "type": "string",
                                          "format": "date"
                                      }
                                  },
                                  {
                                      "name": "services",
                                      "in": "query",
                                      "description": "Comma-separated list of AWS services (optional)",
                                      "required": false,
                                      "schema": {
                                          "type": "string"
                                      }
                                  },
                                  {
                                      "name": "granularity",
                                      "in": "query",
                                      "description": "Time granularity of the forecast",
                                      "required": false,
                                      "schema": {
                                          "type": "string",
                                          "enum": [
                                              "DAILY",
                                              "MONTHLY"
                                          ],
                                          "default": "MONTHLY"
                                      }
                                  }
                              ],
                              "responses": {
                                  "200": {
                                      "description": "Successful operation",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "type": "object",
                                                  "properties": {
                                                      "messageVersion": {
                                                          "type": "string"
                                                      },
                                                      "response": {
                                                          "type": "object",
                                                          "properties": {
                                                              "body": {
                                                                  "type": "object",
                                                                  "properties": {
                                                                      "message": {
                                                                          "type": "string"
                                                                      },
                                                                      "period": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "start": {
                                                                                  "type": "string"
                                                                              },
                                                                              "end": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "requested_period_forecast": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "amount": {
                                                                                  "type": "string"
                                                                              },
                                                                              "unit": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "total_forecast": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "amount": {
                                                                                  "type": "string"
                                                                              },
                                                                              "unit": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      },
                                                                      "granularity": {
                                                                          "type": "string"
                                                                      },
                                                                      "forecast_by_period": {
                                                                          "type": "array",
                                                                          "items": {
                                                                              "type": "object",
                                                                              "properties": {
                                                                                  "time_period": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "start": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "end": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  },
                                                                                  "forecast_amount": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "amount": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "unit": {
                                                                                              "type": "string"
                                                                                          }
                                                                                      }
                                                                                  },
                                                                                  "prediction_interval": {
                                                                                      "type": "object",
                                                                                      "properties": {
                                                                                          "lower": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "upper": {
                                                                                              "type": "string"
                                                                                          },
                                                                                          "level": {
                                                                                              "type": "integer"
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      },
                                                                      "services_included": {
                                                                          "type": "array",
                                                                          "items": {
                                                                              "type": "string"
                                                                          }
                                                                      },
                                                                      "metadata": {
                                                                          "type": "object",
                                                                          "properties": {
                                                                              "prediction_interval_level": {
                                                                                  "type": "integer"
                                                                              },
                                                                              "estimated_total_lower": {
                                                                                  "type": "string"
                                                                              },
                                                                              "estimated_total_upper": {
                                                                                  "type": "string"
                                                                              }
                                                                          }
                                                                      }
                                                                  }
                                                              }
                                                          }
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  },
                                  "400": {
                                      "description": "Bad request",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "$ref": "#/components/schemas/Error"
                                              }
                                          }
                                      }
                                  },
                                  "500": {
                                      "description": "Internal server error",
                                      "content": {
                                          "application/json": {
                                              "schema": {
                                                  "$ref": "#/components/schemas/Error"
                                              }
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  },
                  "components": {
                      "schemas": {
                          "Error": {
                              "type": "object",
                              "properties": {
                                  "message": {
                                      "type": "string"
                                  }
                              }
                          }
                      }
                  }
              }

  SupervisorAgent:
    Type: AWS::Bedrock::Agent
    DependsOn: CostAnalysisAgentAlias
    Properties:
      AgentName: FinOpsSupervisorAgent
      Description: You are an AI Agent which will get FinOps Data.
      Instruction: |
        "You are the main supervisor agent that coordinates with two specialized collaborator agents to get start and end date, provide comprehensive AWS cost analysis, cost forecast and optimization recommendations. You intelligently route requests to specific agents and combine insights when needed and output the answer in a well formated manner.   

        Collaborator Agents
        CostAnalysisAgent: Handles date calculation, detailed cost breakdowns, historical analysis and forecast analysis
        CostOptimizationAgent: Provides optimization recommendations and savings opportunities

        Core Capabilities
        Route cost-related queries to appropriate specialist agents
        Combine and synthesize information from multiple agents when relevant
        Provide unified, well-formatted responses with emojis
        Handle natural language queries about AWS costs and optimization
        Ensure accurate reporting of costs and savings

        Interaction Pattern
        Analyze user query to determine appropriate routing:
        Cost Analysis queries → CostAnalysisAgent
        Cost Forecast queries → CostAnalysisAgent
        Cost Optimization queries → CostOptimizationAgent
        Hybrid queries → Combination of relevant agents

        DO NOT:
        - determine the specific time periods on your own

        DO:
        - route the date range determination to CostAnalysisAgent

        For Cost Analysis queries, you should ALWAYS follow this format:
        - The total cost for the period
        - Time periods (start and end dates). always provide the start and end date in the output.
        - All costs in USD
        - Add emojis in your final respones and output in a nice format depending if the items is a list or a pragraph.  

        Please format your response using the following structure:
        1. Start with a main heading using a single # symbol
        2. Include the total cost and period information as bold text with double asterisks (**)
        3. Add a subheading 'Cost Summary' using two # symbols
        4. Present the costs as a numbered list where each service name is in bold
        5. End with any notes or additional information in bold

        Route to CostAnalysisAgent when:
        Questions to determine specific time periods
        Requests for cost breakdowns
        Questions about services
        Questions about usage types
        Questions about linked accounts
        Questions about regions
        Queries about spending trends
        Historical cost analysis
        Questions about cost forecast/projection/estimate

        Route to CostOptimizationAgent when:
        Questions about saving opportunities
        Requests for resource optimization
        Requests for resource details like EC2 Instance IDs or ARN associated with the savings opportunity
        Queries about idle resources
        Questions about Reserved Instances
        Requests for efficiency recommendations

        Route to Multiple Agents when:
        Complex queries requiring both historical analysis and optimization
        Requests for comprehensive cost management
        Questions combining spending patterns and optimization opportunities

        Response Formatting

        For Lists:
        Use bullet points with relevant emojis
        Group similar items
        Include clear headers
        Maintain consistent spacing

        For Tables:
        Clear column headers
        Aligned columns
        Monetary values right-aligned
        Include totals where appropriate

        For Paragraphs:
        Short, focused paragraphs
        Relevant emojis at section starts
        Clear topic sentences
        Logical flow of information
        Example Query Handling
        User: 'What's my AWS spending situation and how can I optimize it?''

        Action:
        Route to CostAnalysisAgent for current spending analysis
        Route to CostOptimizationAgent for optimization opportunities

        Combine insights into unified response with:
        Current spending summary
        Top cost drivers 
        Saving opportunities
        Recommended actions
        Limitations and Boundaries

        Only provide AWS cost-related information
        Maintain focus on financial and optimization aspects
        Refer security/performance questions to appropriate channels
        Clearly state when data is estimated or projected
        Always verify date and time context for queries
        Always make sure complete data set is available before providing analysis
        If you have received an answer previously, request updated details
        Don't combine savings with actual spend, show them separately
        
        By following these instructions, you will be able to effectively coordinate with the CostAnalysisAgent and CostOptimizationAgent to provide comprehensive, accurate, and well-formatted responses to AWS cost-related queries."
      AutoPrepare: true
      AgentResourceRoleArn: !GetAtt FinOpsSupervisorAgentExecutionRole.Arn
      IdleSessionTTLInSeconds: 1800
      FoundationModel: !Ref SupervisorFoundationModel
      AgentCollaboration: SUPERVISOR
      AgentCollaborators:
        - AgentDescriptor: 
            AliasArn: !GetAtt CostAnalysisAgentAlias.AgentAliasArn
          CollaborationInstruction: "- Questions about specific time periods
           - Requests for cost breakdowns
           - Questions about usage types
           - Queries about spending trends
           - Historical cost analysis"
          CollaboratorName: CostAnalysisAgent
          RelayConversationHistory: DISABLED   
        - AgentDescriptor: 
            AliasArn: !GetAtt CostOptimizationAgentAlias.AgentAliasArn
          CollaborationInstruction: "-  Questions about saving opportunities
          - Requests for resource optimization
          - Queries about idle resources
          - Questions about Reserved Instances
          - Requests for efficiency recommendations
          - Request for resource information like ARN, EC2 Instance IDs
          - Never consult CalculatorAgent, just pull the recommendations and display them with recommendations"
          CollaboratorName: CostOptimizationAgent
          RelayConversationHistory: TO_COLLABORATOR                   

  DateTimeLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CostAnalysisAgent
    Properties:
      FunctionName: !Ref ClockandCalendar
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !GetAtt CostAnalysisAgent.AgentArn

  CostAnalysisLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CostAnalysisAgent
    Properties:
      FunctionName: !Ref CostAnalysis
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !GetAtt CostAnalysisAgent.AgentArn   

  CostForecastLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CostAnalysisAgent
    Properties:
      FunctionName: !Ref CostForecast
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !GetAtt CostAnalysisAgent.AgentArn 

  TrustedAdvisorListRecommendationResourceLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CostOptimizationAgent
    Properties:
      FunctionName: !Ref TrustedAdvisorListRecommendationResources
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !GetAtt CostOptimizationAgent.AgentArn         

  TrustedAdvisorListRecommendationsLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CostOptimizationAgent
    Properties:
      FunctionName: !Ref TrustedAdvisorListRecommendations
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !GetAtt CostOptimizationAgent.AgentArn               

  CostRecommendationLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CostOptimizationAgent
    Properties:
      FunctionName: !Ref ClockandCalendar
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !GetAtt CostOptimizationAgent.AgentArn    

  # Lambda Function 1: TrustedAdvisorListRecommendationResources
  TrustedAdvisorListRecommendationResources:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: TrustedAdvisorListRecommendationResources
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: nodejs20.x
      Code:
        ZipFile: |
          const { pipeline } = require('stream/promises');
          const { Readable } = require('stream');
          const { TrustedAdvisorClient, ListRecommendationResourcesCommand } = require("@aws-sdk/client-trustedadvisor");

          const client = new TrustedAdvisorClient({});
          const CHUNK_SIZE = 25 * 1024; // 25KB

          const streamFunctionResponse = async (function_response, responseStream) => {
              const jsonResponse = JSON.stringify(function_response);
              const size = Buffer.byteLength(jsonResponse);
              console.log("function_response_size:", size / 1024);
              
              const requestStream = Readable.from(jsonResponse);

              for await (const chunk of requestStream) {
                  console.log("chunk:", chunk.length / 1024);
                  console.log("chunk_size:", CHUNK_SIZE / 1024);
                  if (chunk.length > CHUNK_SIZE) {
                      for (let i = 0; i < chunk.length; i += CHUNK_SIZE) {
                          console.log("i:", i);
                          await responseStream.write(chunk.slice(i, i + CHUNK_SIZE));
                      }
                  } else {
                      await responseStream.write(chunk);
                  }
              }

              responseStream.end();
          }

          module.exports.handler = awslambda.streamifyResponse(async (event, responseStream, context) => {
              try {
                  console.log("Received event:", JSON.stringify(event, null, 2));
                  responseStream.setContentType("application/json");

                  // Extract recommendationIdentifier from parameters
                  const recommendationIdentifier = event.parameters?.find(
                      param => param.name === "recommendationIdentifier"
                  )?.value;

                  const get_resource_list = async (recommendationIdentifier) => {
                      const resources = [];
                      
                      try {
                          const input = {
                              maxResults: 200, // Adjust as needed
                              recommendationIdentifier: recommendationIdentifier,
                          };
                          
                          let hasMoreResults = true;
                          let nextToken = undefined;
                          
                          while (hasMoreResults) {
                              if (nextToken) {
                                  input.nextToken = nextToken;
                              }
                              
                              const command = new ListRecommendationResourcesCommand(input);
                              const response = await client.send(command);
                              console.log("Resource-Response:", JSON.stringify(response, null, 2));

                              if (response.recommendationResourceSummaries) {
                                  resources.push(...response.recommendationResourceSummaries.map(resource => ({
                                      id: resource.id,
                                      taResourceArn: resource.arn,
                                      awsResourceId: resource.awsResourceId,
                                      regionCode: resource.regionCode,
                                      status: resource.status,
                                      metadata: resource.metadata,
                                      lastUpdatedAt: resource.lastUpdatedAt,
                                      exclusionStatus: resource.exclusionStatus,
                                      recommendationArn: resource.recommendationArn
                                  })));
                              }
                              
                              nextToken = response.nextToken;
                              hasMoreResults = !!nextToken;
                          }
                          
                          return resources;
                          
                      } catch (e) {
                          console.error("Error retrieving resources:", e);
                          throw e;
                      }
                  };
                  
                  if (!recommendationIdentifier) {
                      throw new Error("recommendationIdentifier is required");
                  }

                  // Get all resources
                  const resources = await get_resource_list(recommendationIdentifier);
                  
                  // Prepare response object
                  const resourcesData = {
                      summary: {
                          totalResources: resources.length,
                          lastUpdated: new Date().toISOString().replace('T', ' ').substr(0, 19)
                      },
                      resources: resources
                  };

                  // Prepare response
                  const response_body = {
                      TEXT: {
                          body: JSON.stringify({
                              resourcesData: resourcesData
                          })
                      }
                  };

                  const function_response = {
                      messageVersion: "1.0",
                      response: {
                          actionGroup: event.actionGroup || '',
                          function: event.function,
                          functionResponse: {
                              responseBody: response_body
                          }
                      },
                  };
                  
                  console.log("Resource List Response:", JSON.stringify(function_response, null, 2));
                  
                  await streamFunctionResponse(function_response, responseStream);
                  
              } catch (e) {
                  console.error("Unexpected error:", e);
                  const error_response_body = {
                      TEXT: {
                          body: JSON.stringify({
                              error: e.message
                          })
                      }
                  };

                  const error_function_response = {
                      messageVersion: "1.0",
                      response: {
                          actionGroup: event.actionGroup || '',
                          function: event.function,
                          responseState: 'REPROMPT',
                          functionResponse: {
                              responseBody: error_response_body
                          }
                      },
                  };

                  await streamFunctionResponse(error_function_response, responseStream);
              }
          });
      Description: 'Lambda function to lit TA resources'
      Timeout: 100
      MemorySize: 128

  # Lambda Function 2: TrustedAdvisorListRecommendations
  TrustedAdvisorListRecommendations:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: TrustedAdvisorListRecommendations
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: nodejs20.x
      Code:
        ZipFile: |
          const { pipeline } = require('stream/promises');
          const { Readable } = require('stream');
          const { TrustedAdvisorClient, ListRecommendationsCommand, GetRecommendationCommand } = require("@aws-sdk/client-trustedadvisor");

          const client = new TrustedAdvisorClient({});
          const CHUNK_SIZE = 25 * 1024; // 20KB

          const streamFunctionResponse = async (function_response, responseStream) => {
              
              const jsonResponse = JSON.stringify(function_response);
              const size = Buffer.byteLength(jsonResponse);
              console.log("function_response_size:", size / 1024);
              
              // Create a readable stream from the JSON response
              const requestStream = Readable.from(jsonResponse);

              // Stream the response in chunks
              for await (const chunk of requestStream) {
                  //log the size of chunk
                  console.log("chunk:", chunk.length / 1024);
                  console.log("chunk_size:", CHUNK_SIZE / 1024);
                  if (chunk.length > CHUNK_SIZE) {
                      // If the chunk is larger than the chunk size, split it
                      for (let i = 0; i < chunk.length; i += CHUNK_SIZE) {
                          console.log("i:", i);
                          await responseStream.write(chunk.slice(i, i + CHUNK_SIZE));
                      }
                  } else {
                      await responseStream.write(chunk);
                  }
              }

              // End the stream
              responseStream.end();
          }

          module.exports.handler = awslambda.streamifyResponse(async (event, responseStream ,context) => {
              try {
                  console.log("Received event:", JSON.stringify(event, null, 2));
                  // Set the content type to application/json
                  responseStream.setContentType("application/json");
                  
                  const get_trusted_advisor_findings = async () => {
                      const findings = [];
                      
                      try {
                          // Get all cost optimization recommendations
                          const input = {
                              maxResults: 200, // Adjust as needed
                              pillar: "cost_optimizing",
                              status: "warning", // Get recommendations that need attention
                          };
                          
                          let hasMoreResults = true;
                          let nextToken = undefined;
                          
                          while (hasMoreResults) {
                              if (nextToken) {
                                  input.nextToken = nextToken;
                              }
                              
                              const command = new ListRecommendationsCommand(input);
                              const response = await client.send(command);
                              console.log("TA-Response:", JSON.stringify(response, null, 2));
                              for (const recommendation of response.recommendationSummaries) {
                                  console.log("TA-Recommendation:", JSON.stringify(recommendation, null, 2));
                                  try {
                                      // Get detailed recommendation data
                                      const detailCommand = new GetRecommendationCommand({
                                          recommendationIdentifier: recommendation.arn
                                      });
                                      const detailResponse = await client.send(detailCommand);
                                      
                                      const costAggregates = recommendation.pillarSpecificAggregates?.costOptimizing || {};
                                      const resourceAggregates = recommendation.resourcesAggregates || {};
                                      
                                      findings.push({
                                          recommendationIdentifier: recommendation.arn,
                                          checkName: recommendation.name,
                                          checkId: recommendation.id,
                                          status: recommendation.status,
                                          description: detailResponse.recommendation?.description || '',
                                          recommendedAction: detailResponse.recommendation?.recommendedActions?.[0]?.description || '',
                                          resourceCount: resourceAggregates.errorCount + resourceAggregates.warningCount,
                                          estimatedMonthlySavings: costAggregates.estimatedMonthlySavings || 0,
                                          resources: detailResponse.recommendation?.resources?.map(resource => ({
                                              resourceId: resource.resourceId || '',
                                              region: resource.metadata?.region || '',
                                              status: resource.status,
                                              metadata: resource.metadata || {}
                                          })) || []
                                      });
                                      
                                  } catch (e) {
                                      console.error(`Error processing recommendation ${recommendation.name}:`, e);
                                  }
                              }
                              
                              nextToken = response.nextToken;
                              hasMoreResults = !!nextToken;
                          }
                          
                          // Sort findings by estimated savings
                          findings.sort((a, b) => (b.estimatedMonthlySavings || 0) - (a.estimatedMonthlySavings || 0));
                          
                          return findings;
                          
                      } catch (e) {
                          console.error("Error retrieving recommendations:", e);
                          throw e;
                      }
                  };

                  // Get all findings
                  const findings = await get_trusted_advisor_findings();
                  
                  // Calculate total savings
                  const totalSavings = findings.reduce((sum, finding) => 
                      sum + (finding.estimatedMonthlySavings || 0), 0);
                  
                  // Prepare the checks object
                  const checks = {
                      summary: {
                          totalFindings: findings.length,
                          totalPotentialSavings: Number(totalSavings.toFixed(2)),
                          lastUpdated: new Date().toISOString().replace('T', ' ').substr(0, 19)
                      },
                      findings: findings
                  };

                  // Prepare response
                  const response_body = {
                      TEXT: {
                          body: JSON.stringify({
                              checks: checks
                          })
                      }
                  };

                  const function_response = {
                      messageVersion: "1.0",
                      response: {
                          actionGroup: event.actionGroup || '',
                          function: event.function,
                          functionResponse: {
                              responseBody: response_body
                          }
                      },
                  };
                  
                  
                  console.log("Trusted Advisor Response:", JSON.stringify(function_response, null, 2));
                  
                  await streamFunctionResponse(function_response, responseStream);
                  
              } catch (e) {
                  console.error("Unexpected error:", e);
                  const error_response_body = {
                      TEXT: {
                          body: JSON.stringify({
                              error: e.message
                          })
                      }
                  };

                  const error_function_response = {
                      messageVersion: "1.0",
                      response: {
                          actionGroup: event.actionGroup || '',
                          function: event.function,
                          functionResponse: {
                              responseBody: error_response_body
                          }
                      },
                  };

                  await streamFunctionResponse(error_function_response, responseStream);
              }
          });      
      Description: 'Lambda function to lit TA resources'
      Timeout: 100
      MemorySize: 128

  # Lambda Function 3: Get-Cost-From-Cost-Explorer
  CostAnalysis:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CostAnalysis
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.13
      Code:
        ZipFile: |
          import boto3
          from datetime import datetime, timedelta
          import json
          import traceback
          from botocore.exceptions import ClientError
          import time
          from decimal import Decimal, ROUND_HALF_UP, ROUND_UP
          import re
          from typing import List, Dict, Union, Any

          def get_aws_service_mapping():
              """
              Returns a dictionary mapping common service names/aliases to their official AWS service names
              """
              return {
                  # Analytics
                  'ATHENA': ['Amazon Athena', 'Athena'],
                  'CLOUDSEARCH': ['Amazon CloudSearch', 'CloudSearch'],
                  'DATAZONE': ['Amazon DataZone', 'DataZone'],
                  'EMR': ['Amazon EMR', 'EMR', 'Elastic MapReduce'],
                  'EMR_SERVERLESS': ['Amazon EMR Serverless', 'EMR Serverless'],
                  'FINSPACE': ['Amazon FinSpace', 'FinSpace'],
                  'KINESIS': ['Amazon Kinesis', 'Kinesis'],
                  'KINESIS_DATA_ANALYTICS': ['Amazon Kinesis Data Analytics', 'Kinesis Analytics'],
                  'KINESIS_DATA_FIREHOSE': ['Amazon Kinesis Data Firehose', 'Kinesis Firehose'],
                  'KINESIS_DATA_STREAMS': ['Amazon Kinesis Data Streams', 'Kinesis Streams'],
                  'KINESIS_VIDEO_STREAMS': ['Amazon Kinesis Video Streams', 'Kinesis Video'],
                  'LAKE_FORMATION': ['AWS Lake Formation', 'Lake Formation'],
                  'MANAGED_STREAMING_APACHE_KAFKA': ['Amazon Managed Streaming for Apache Kafka', 'Amazon MSK', 'MSK'],
                  'OPENSEARCH': ['Amazon OpenSearch Service', 'OpenSearch', 'Amazon OpenSearch'],
                  'QUICKSIGHT': ['Amazon QuickSight', 'QuickSight'],
                  'REDSHIFT': ['Amazon Redshift', 'Redshift'],
                  'GLUE': ['AWS Glue', 'Glue'],
                  'CLEAN_ROOMS': ['AWS Clean Rooms', 'Clean Rooms'],
                  'DATA_EXCHANGE': ['AWS Data Exchange', 'Data Exchange'],
                  'DATA_PIPELINE': ['AWS Data Pipeline', 'Data Pipeline'],

                  # Application Integration
                  'API_GATEWAY': ['Amazon API Gateway', 'API Gateway', 'APIGateway'],
                  'APPFLOW': ['Amazon AppFlow', 'AppFlow'],
                  'EVENTBRIDGE': ['Amazon EventBridge', 'EventBridge', 'CloudWatch Events'],
                  'MANAGED_WORKFLOWS_APACHE_AIRFLOW': ['Amazon Managed Workflows for Apache Airflow', 'MWAA', 'Managed Airflow'],
                  'MQ': ['Amazon MQ', 'MQ'],
                  'SNS': ['Amazon Simple Notification Service', 'Amazon SNS', 'SNS'],
                  'SQS': ['Amazon Simple Queue Service', 'Amazon SQS', 'SQS'],
                  'APP_SYNC': ['AWS AppSync', 'AppSync'],
                  'CONSOLE_MOBILE_APPLICATION': ['AWS Console Mobile Application', 'Console Mobile App'],
                  'EXPRESS_WORKFLOWS': ['AWS Express Workflows', 'Express Workflows'],
                  'STEP_FUNCTIONS': ['AWS Step Functions', 'Step Functions', 'StepFunctions'],
                  'MICROSERVICE_EXTRACTOR': ['AWS Microservice Extractor for .NET', 'Microservice Extractor'],

                  # AWS Cost Management
                  'APPLICATION_COST_PROFILER': ['AWS Application Cost Profiler', 'Cost Profiler'],
                  'BILLING_CONDUCTOR': ['AWS Billing Conductor', 'Billing Conductor'],
                  'BUDGETS': ['AWS Budgets', 'Budgets'],
                  'COST_EXPLORER': ['AWS Cost Explorer', 'Cost Explorer'],
                  'COST_AND_USAGE_REPORT': ['AWS Cost and Usage Report', 'CUR', 'Cost and Usage Report'],
                  'RESERVED_INSTANCE_REPORTING': ['Reserved Instance Reporting', 'RI Reporting'],
                  'SAVINGS_PLANS': ['Savings Plans'],

                  # Blockchain
                  'MANAGED_BLOCKCHAIN': ['Amazon Managed Blockchain', 'Managed Blockchain'],
                  'QUANTUM_LEDGER_DATABASE': ['Amazon Quantum Ledger Database', 'QLDB'],

                  # Business Applications
                  'ALEXA_FOR_BUSINESS': ['Alexa for Business', 'A4B'],
                  'CHIME': ['Amazon Chime', 'Chime'],
                  'CHIME_SDK': ['Amazon Chime SDK', 'Chime SDK'],
                  'CONNECT': ['Amazon Connect', 'Connect'],
                  'HONEYCODE': ['Amazon Honeycode', 'Honeycode'],
                  'PINPOINT': ['Amazon Pinpoint', 'Pinpoint'],
                  'PINPOINT_SMS_VOICE': ['Amazon Pinpoint SMS and Voice', 'Pinpoint SMS', 'Pinpoint Voice'],
                  'SIMPLE_EMAIL_SERVICE': ['Amazon Simple Email Service', 'Amazon SES', 'SES'],
                  'WORKDOCS': ['Amazon WorkDocs', 'WorkDocs'],
                  'WORKMAIL': ['Amazon WorkMail', 'WorkMail'],
                  'SUPPLY_CHAIN': ['AWS Supply Chain', 'Supply Chain'],
                  'WICKR': ['AWS Wickr', 'Wickr'],
                  'PRIVATE_5G': ['AWS Private 5G', 'Private 5G'],

                  # Compute
                  'EC2': ['Amazon Elastic Compute Cloud', 'Amazon EC2', 'EC2', 'AWS EC2'],
                  'EC2_AUTO_SCALING': ['Amazon EC2 Auto Scaling', 'Auto Scaling', 'ASG'],
                  'EC2_SPOT_INSTANCES': ['Amazon EC2 Spot Instances', 'EC2 Spot', 'Spot Instances'],
                  'EC2_IMAGE_BUILDER': ['Amazon EC2 Image Builder', 'EC2 Image Builder', 'Image Builder'],
                  'LIGHTSAIL': ['Amazon Lightsail', 'Lightsail'],
                  'APP_RUNNER': ['AWS App Runner', 'App Runner'],
                  'BATCH': ['AWS Batch', 'Batch'],
                  'COMPUTE_OPTIMIZER': ['AWS Compute Optimizer', 'Compute Optimizer'],
                  'ELASTIC_BEANSTALK': ['AWS Elastic Beanstalk', 'Elastic Beanstalk', 'Beanstalk'],
                  'LAMBDA': ['AWS Lambda', 'Lambda', 'AWS Lambda Function'],
                  'LOCAL_ZONES': ['AWS Local Zones', 'Local Zones'],
                  'NITRO_ENCLAVES': ['AWS Nitro Enclaves', 'Nitro Enclaves'],
                  'OUTPOSTS': ['AWS Outposts', 'Outposts'],
                  'PARALLEL_CLUSTER': ['AWS ParallelCluster', 'ParallelCluster'],
                  'SERVERLESS_APPLICATION_REPOSITORY': ['AWS Serverless Application Repository', 'SAR', 'Serverless Repo'],
                  'SIMSPACE_WEAVER': ['AWS SimSpace Weaver', 'SimSpace Weaver'],
                  'THINKBOX_DEADLINE': ['AWS Thinkbox Deadline', 'Deadline'],
                  'THINKBOX_FROST': ['AWS Thinkbox Frost', 'Frost'],
                  'THINKBOX_KRAKATOA': ['AWS Thinkbox Krakatoa', 'Krakatoa'],
                  'THINKBOX_SEQUOIA': ['AWS Thinkbox Sequoia', 'Sequoia'],
                  'THINKBOX_STOKE': ['AWS Thinkbox Stoke', 'Stoke'],
                  'THINKBOX_XMESH': ['AWS Thinkbox XMesh', 'XMesh'],
                  'WAVELENGTH': ['AWS Wavelength', 'Wavelength'],
                  'BOTTLEROCKET': ['Bottlerocket'],
                  'NICE_DCV': ['NICE DCV'],
                  'VMWARE_CLOUD': ['VMware Cloud on AWS', 'VMware Cloud'],

                  # Containers
                  'ECR': ['Amazon Elastic Container Registry', 'Amazon ECR', 'ECR'],
                  'ECR_PUBLIC': ['Amazon Elastic Container Registry Public', 'Amazon ECR Public', 'ECR Public'],
                  'ECS': ['Amazon Elastic Container Service', 'Amazon ECS', 'ECS'],
                  'EKS': ['Amazon Elastic Kubernetes Service', 'Amazon EKS', 'EKS'],
                  'EKS_ANYWHERE': ['Amazon EKS Anywhere', 'EKS Anywhere'],
                  'EKS_DISTRO': ['Amazon EKS Distro', 'EKS Distro'],
                  'APP2CONTAINER': ['AWS App2Container', 'App2Container', 'A2C'],
                  'COPILOT': ['AWS Copilot', 'Copilot'],
                  'FARGATE': ['AWS Fargate', 'Fargate'],
                  'RED_HAT_OPENSHIFT': ['Red Hat OpenShift Service on AWS', 'ROSA', 'OpenShift'],

                  # Database
                  'AURORA': ['Amazon Aurora', 'Aurora'],
                  'DOCUMENTDB': ['Amazon DocumentDB', 'DocumentDB'],
                  'DYNAMODB': ['Amazon DynamoDB', 'DynamoDB'],
                  'ELASTICACHE': ['Amazon ElastiCache', 'ElastiCache'],
                  'KEYSPACES': ['Amazon Keyspaces', 'Keyspaces'],
                  'MEMORYDB': ['Amazon MemoryDB for Redis', 'MemoryDB'],
                  'NEPTUNE': ['Amazon Neptune', 'Neptune'],
                  'RDS': ['Amazon Relational Database Service', 'Amazon RDS', 'RDS'],
                  'TIMESTREAM': ['Amazon Timestream', 'Timestream'],
                  'DATABASE_MIGRATION_SERVICE': ['AWS Database Migration Service', 'DMS', 'Database Migration'],

                  # Developer Tools
                  'CLOUD9': ['AWS Cloud9', 'Cloud9'],
                  'CLOUD_CONTROL_API': ['AWS Cloud Control API', 'Cloud Control'],
                  'CLOUDSHELL': ['AWS CloudShell', 'CloudShell'],
                  'CODECATALYST': ['Amazon CodeCatalyst', 'CodeCatalyst'],
                  'CODEARTIFACT': ['AWS CodeArtifact', 'CodeArtifact'],
                  'CODEBUILD': ['AWS CodeBuild', 'CodeBuild'],
                  'CODECOMMIT': ['AWS CodeCommit', 'CodeCommit'],
                  'CODEDEPLOY': ['AWS CodeDeploy', 'CodeDeploy'],
                  'CODEGURU': ['Amazon CodeGuru', 'CodeGuru'],
                  'CODEGURU_PROFILER': ['Amazon CodeGuru Profiler', 'CodeGuru Profiler'],
                  'CODEGURU_REVIEWER': ['Amazon CodeGuru Reviewer', 'CodeGuru Reviewer'],
                  'CODEPIPELINE': ['AWS CodePipeline', 'CodePipeline'],
                  'CODESTAR': ['AWS CodeStar', 'CodeStar'],
                  'CODESTAR_CONNECTIONS': ['AWS CodeStar Connections', 'CodeStar Connections'],
                  'CODESTAR_NOTIFICATIONS': ['AWS CodeStar Notifications', 'CodeStar Notifications'],
                  'COMMAND_LINE_INTERFACE': ['AWS Command Line Interface', 'AWS CLI', 'CLI'],
                  'CORRETTO': ['Amazon Corretto', 'Corretto'],
                  'FAULT_INJECTION_SIMULATOR': ['AWS Fault Injection Simulator', 'FIS'],
                  'TOOLS_AND_SDKS': ['AWS Tools and SDKs', 'SDKs'],
                  'X_RAY': ['AWS X-Ray', 'X-Ray'],

                  # End User Computing
                  'APPSTREAM': ['Amazon AppStream 2.0', 'AppStream'],
                  'WORKSPACES': ['Amazon WorkSpaces', 'WorkSpaces'],
                  'WORKSPACES_WEB': ['Amazon WorkSpaces Web', 'WorkSpaces Web'],
                  'WORKSPACES_APPLICATION_MANAGER': ['AWS WAM', 'WAM'],

                  # Frontend Web & Mobile
                  'AMPLIFY': ['AWS Amplify', 'Amplify'],
                  'DEVICE_FARM': ['AWS Device Farm', 'Device Farm'],
                  'LOCATION': ['Amazon Location Service', 'Location Service'],

                  # Game Development
                  'GAMELIFT': ['Amazon GameLift', 'GameLift'],
                  'OPEN_3D_ENGINE': ['Open 3D Engine', 'O3DE'],

                  # Internet of Things (IoT)
                  'FORECASTCLI': ['Amazon ForecastCLI', 'ForecastCLI'],
                  'IOT_1_CLICK': ['AWS IoT 1-Click', 'IoT 1-Click'],
                  'IOT_ANALYTICS': ['AWS IoT Analytics', 'IoT Analytics'],
                  'IOT_CORE': ['AWS IoT Core', 'IoT Core'],
                  'IOT_DEVICE_DEFENDER': ['AWS IoT Device Defender', 'IoT Device Defender'],
                  'IOT_DEVICE_MANAGEMENT': ['AWS IoT Device Management', 'IoT Device Management'],
                  'IOT_EVENTS': ['AWS IoT Events', 'IoT Events'],
                  'IOT_FLEETHUB': ['AWS IoT FleetHub', 'IoT FleetHub'],
                  'IOT_GREENGRASS': ['AWS IoT Greengrass', 'Greengrass'],
                  'IOT_ROBORUNNER': ['AWS IoT RoboRunner', 'RoboRunner'],
                  'IOT_SITEWISE': ['AWS IoT SiteWise', 'SiteWise'],
                  'IOT_TWINMAKER': ['AWS IoT TwinMaker', 'TwinMaker'],
                  'IOT_WIRELESS': ['AWS IoT Wireless', 'IoT Wireless'],
                  'MONITRON': ['Amazon Monitron', 'Monitron'],

                  # Machine Learning & AI
                  'BEDROCK': ['Amazon Bedrock', 'Bedrock'],
                  'COMPREHEND': ['Amazon Comprehend', 'Comprehend'],
                  'CODEWHISPERER': ['Amazon CodeWhisperer', 'CodeWhisperer'],
                  'DEVOPS_GURU': ['Amazon DevOps Guru', 'DevOps Guru'],
                  'ELASTIC_INFERENCE': ['Amazon Elastic Inference', 'Elastic Inference'],
                  'FORECAST': ['Amazon Forecast', 'Forecast'],
                  'FRAUD_DETECTOR': ['Amazon Fraud Detector', 'Fraud Detector'],
                  'HEALTHLAKE': ['Amazon HealthLake', 'HealthLake'],
                  'KENDRA': ['Amazon Kendra', 'Kendra'],
                  'KEYSPHRASES': ['Amazon KeyPhrases', 'KeyPhrases'],
                  'LEX': ['Amazon Lex', 'Lex'],
                  'LOOKOUT_FOR_EQUIPMENT': ['Amazon Lookout for Equipment', 'Lookout Equipment'],
                  'LOOKOUT_FOR_METRICS': ['Amazon Lookout for Metrics', 'Lookout Metrics'],
                  'LOOKOUT_FOR_VISION': ['Amazon Lookout for Vision', 'Lookout Vision'],
                  'MONITRON': ['Amazon Monitron', 'Monitron'],
                  'OMICS': ['Amazon Omics', 'Omics'],
                  'PERSONALIZE': ['Amazon Personalize', 'Personalize'],
                  'POLLY': ['Amazon Polly', 'Polly'],
                  'REKOGNITION': ['Amazon Rekognition', 'Rekognition'],
                  'SAGEMAKER': ['Amazon SageMaker', 'SageMaker'],
                  'SAGEMAKER_GROUND_TRUTH': ['Amazon SageMaker Ground Truth', 'Ground Truth'],
                  'TEXTRACT': ['Amazon Textract', 'Textract'],
                  'TRANSCRIBE': ['Amazon Transcribe', 'Transcribe'],
                  'TRANSLATE': ['Amazon Translate', 'Translate'],
                  'AUGMENTED_AI': ['Amazon Augmented AI', 'A2I'],
                  'DEEP_LEARNING_AMIS': ['AWS Deep Learning AMIs', 'Deep Learning AMIs'],
                  'DEEP_LEARNING_CONTAINERS': ['AWS Deep Learning Containers', 'Deep Learning Containers'],
                  'DEEPCOMPOSER': ['AWS DeepComposer', 'DeepComposer'],
                  'DEEPLENS': ['AWS DeepLens', 'DeepLens'],
                  'DEEPRACER': ['AWS DeepRacer', 'DeepRacer'],
                  'NEURON': ['AWS Neuron', 'Neuron'],
                  'PANORAMA': ['AWS Panorama', 'Panorama'],
                  'TENSORFLOW_ON_AWS': ['TensorFlow on AWS', 'TensorFlow'],

                  # Management & Governance
                  'APPLICATION_AUTO_SCALING': ['Application Auto Scaling'],
                  'CHATBOT': ['AWS Chatbot', 'Chatbot'],
                  'CLOUDFORMATION': ['AWS CloudFormation', 'CloudFormation'],
                  'CLOUDTRAIL': ['AWS CloudTrail', 'CloudTrail', 'Cloud Trail'],
                  'CLOUDWATCH': ['Amazon CloudWatch', 'CloudWatch'],
                  'CLOUDWATCH_LOGS': ['Amazon CloudWatch Logs', 'CloudWatch Logs'],
                  'CLOUDWATCH_METRICS': ['Amazon CloudWatch Metrics', 'CloudWatch Metrics'],
                  'CONFIG': ['AWS Config', 'Config'],
                  'CONTROL_TOWER': ['AWS Control Tower', 'Control Tower'],
                  'DISTRO_FOR_OPENTELEMETRY': ['AWS Distro for OpenTelemetry', 'OpenTelemetry'],
                  'FAULT_INJECTION_SIMULATOR': ['AWS Fault Injection Simulator', 'FIS'],
                  'HEALTH_DASHBOARD': ['AWS Health Dashboard', 'Health Dashboard'],
                  'LICENSE_MANAGER': ['AWS License Manager', 'License Manager'],
                  'MANAGED_GRAFANA': ['Amazon Managed Grafana', 'Managed Grafana'],
                  'MANAGED_SERVICE_FOR_PROMETHEUS': ['Amazon Managed Service for Prometheus', 'Managed Prometheus'],
                  'MANAGEMENT_CONSOLE': ['AWS Management Console', 'Management Console'],
                  'OPS_WORKS': ['AWS OpsWorks', 'OpsWorks'],
                  'ORGANIZATIONS': ['AWS Organizations', 'Organizations'],
                  'PERSONAL_HEALTH_DASHBOARD': ['AWS Personal Health Dashboard', 'Personal Health'],
                  'PROTON': ['AWS Proton', 'Proton'],
                  'RESILIENCE_HUB': ['AWS Resilience Hub', 'Resilience Hub'],
                  'RESOURCE_EXPLORER': ['AWS Resource Explorer', 'Resource Explorer'],
                  'SERVICE_CATALOG': ['AWS Service Catalog', 'Service Catalog'],
                  'SERVICE_MANAGEMENT_CONNECTOR': ['AWS Service Management Connector', 'Service Management'],
                  'SYSTEMS_MANAGER': ['AWS Systems Manager', 'Systems Manager', 'SSM'],
                  'TRUSTED_ADVISOR': ['AWS Trusted Advisor', 'Trusted Advisor'],
                  'WELL_ARCHITECTED_TOOL': ['AWS Well-Architected Tool', 'Well-Architected'],

                  # Media Services
                  'ELASTIC_TRANSCODER': ['Amazon Elastic Transcoder', 'Elastic Transcoder'],
                  'ELEMENTAL_APPLIANCES_SOFTWARE': ['AWS Elemental Appliances and Software', 'Elemental'],
                  'ELEMENTAL_CONDUCTOR': ['AWS Elemental Conductor', 'Conductor'],
                  'ELEMENTAL_DELTA': ['AWS Elemental Delta', 'Delta'],
                  'ELEMENTAL_LINK': ['AWS Elemental Link', 'Elemental Link'],
                  'ELEMENTAL_LIVE': ['AWS Elemental Live', 'Elemental Live'],
                  'ELEMENTAL_MEDIACONNECT': ['AWS Elemental MediaConnect', 'MediaConnect'],
                  'ELEMENTAL_MEDIACONVERT': ['AWS Elemental MediaConvert', 'MediaConvert'],
                  'ELEMENTAL_MEDIALIVE': ['AWS Elemental MediaLive', 'MediaLive'],
                  'ELEMENTAL_MEDIAPACKAGE': ['AWS Elemental MediaPackage', 'MediaPackage'],
                  'ELEMENTAL_MEDIASTORE': ['AWS Elemental MediaStore', 'MediaStore'],
                  'ELEMENTAL_MEDIATAILOR': ['AWS Elemental MediaTailor', 'MediaTailor'],
                  'ELEMENTAL_SERVER': ['AWS Elemental Server', 'Elemental Server'],
                  'INTERACTIVE_VIDEO_SERVICE': ['Amazon Interactive Video Service', 'IVS'],
                  'NIMBLE_STUDIO': ['Amazon Nimble Studio', 'Nimble Studio'],

                  # Migration & Transfer
                  'APPLICATION_DISCOVERY_SERVICE': ['AWS Application Discovery Service', 'ADS'],
                  'APPLICATION_MIGRATION_SERVICE': ['AWS Application Migration Service', 'MGN'],
                  'DATASYNC': ['AWS DataSync', 'DataSync'],
                  'MIGRATION_EVALUATOR': ['AWS Migration Evaluator', 'Migration Evaluator'],
                  'MIGRATION_HUB': ['AWS Migration Hub', 'Migration Hub'],
                  'MIGRATION_HUB_REFACTOR_SPACES': ['AWS Migration Hub Refactor Spaces', 'Refactor Spaces'],
                  'SERVER_MIGRATION_SERVICE': ['AWS Server Migration Service', 'SMS'],
                  'TRANSFER_FAMILY': ['AWS Transfer Family', 'Transfer'],
                  'MAINFRAME_MODERNIZATION': ['AWS Mainframe Modernization', 'Mainframe Modernization'],

                  # Networking & Content Delivery
                  'API_GATEWAY': ['Amazon API Gateway', 'API Gateway', 'APIGateway'],
                  'CLOUDFRONT': ['Amazon CloudFront', 'CloudFront'],
                  'CLOUD_MAP': ['AWS Cloud Map', 'Cloud Map'],
                  'DIRECT_CONNECT': ['AWS Direct Connect', 'Direct Connect', 'DX'],
                  'GLOBAL_ACCELERATOR': ['AWS Global Accelerator', 'Global Accelerator'],
                  'PRIVATE_5G': ['AWS Private 5G', 'Private 5G'],
                  'PRIVATELINK': ['AWS PrivateLink', 'PrivateLink'],
                  'ROUTE_53': ['Amazon Route 53', 'Route 53', 'Route53'],
                  'ROUTE_53_RESOLVER': ['Amazon Route 53 Resolver', 'Route 53 Resolver'],
                  'VPC': ['Amazon Virtual Private Cloud', 'Amazon VPC', 'VPC'],
                  'VPC_LATTICE': ['Amazon VPC Lattice', 'VPC Lattice'],
                  'NETWORK_FIREWALL': ['AWS Network Firewall', 'Network Firewall', 'NetworkFirewall'],
                  'NETWORK_MANAGER': ['AWS Network Manager', 'Network Manager'],
                  'TRANSIT_GATEWAY': ['AWS Transit Gateway', 'Transit Gateway', 'TGW'],
                  'APP_MESH': ['AWS App Mesh', 'App Mesh'],
                  'SITE_TO_SITE_VPN': ['AWS Site-to-Site VPN', 'VPN'],
                  'CLIENT_VPN': ['AWS Client VPN', 'Client VPN'],

                  # Quantum Technologies
                  'BRAKET': ['Amazon Braket', 'Braket'],
                  'QUANTUM_SOLUTIONS_LAB': ['AWS Quantum Solutions Lab', 'Quantum Solutions'],

                  # Robotics
                  'ROBOMAKER': ['AWS RoboMaker', 'RoboMaker'],

                  # Satellite
                  'GROUND_STATION': ['AWS Ground Station', 'Ground Station'],

                  # Security, Identity & Compliance
                  'ARTIFACT': ['AWS Artifact', 'Artifact'],
                  'AUDIT_MANAGER': ['AWS Audit Manager', 'Audit Manager'],
                  'CERTIFICATE_MANAGER': ['AWS Certificate Manager', 'ACM', 'Certificate Manager'],
                  'CLOUDHSM': ['AWS CloudHSM', 'CloudHSM'],
                  'COGNITO': ['Amazon Cognito', 'Cognito'],
                  'DETECTIVE': ['Amazon Detective', 'Detective'],
                  'DIRECTORY_SERVICE': ['AWS Directory Service', 'Directory Service', 'AD Connector'],
                  'FIREWALL_MANAGER': ['AWS Firewall Manager', 'Firewall Manager'],
                  'GUARDDUTY': ['Amazon GuardDuty', 'GuardDuty', 'Guard Duty'],
                  'IAM': ['AWS Identity and Access Management', 'IAM', 'Identity and Access Management'],
                  'IAM_IDENTITY_CENTER': ['AWS IAM Identity Center', 'IAM Identity Center', 'Single Sign-On'],
                  'INSPECTOR': ['Amazon Inspector', 'Inspector'],
                  'INSPECTOR_CLASSIC': ['Amazon Inspector Classic', 'Inspector Classic'],
                  'KMS': ['AWS Key Management Service', 'AWS KMS', 'KMS'],
                  'MACIE': ['Amazon Macie', 'Macie'],
                  'NETWORK_FIREWALL': ['AWS Network Firewall', 'Network Firewall'],
                  'PRIVATE_CERTIFICATE_AUTHORITY': ['AWS Private Certificate Authority', 'Private CA'],
                  'RESOURCE_ACCESS_MANAGER': ['AWS Resource Access Manager', 'RAM'],
                  'SECRETS_MANAGER': ['AWS Secrets Manager', 'Secrets Manager'],
                  'SECURITY_HUB': ['AWS Security Hub', 'Security Hub'],
                  'SHIELD': ['AWS Shield', 'Shield'],
                  'SIGNER': ['AWS Signer', 'Signer'],
                  'VERIFIED_PERMISSIONS': ['Amazon Verified Permissions', 'Verified Permissions'],
                  'WAF': ['AWS WAF', 'WAF', 'Web Application Firewall'],
                  'SECURITY_LAKE': ['Amazon Security Lake', 'Security Lake'],
                  'VERIFIED_ACCESS': ['AWS Verified Access', 'Verified Access'],

                  # Serverless
                  'LAMBDA': ['AWS Lambda', 'Lambda', 'Lambda Function'],
                  'FARGATE': ['AWS Fargate', 'Fargate'],
                  'AURORA_SERVERLESS': ['Amazon Aurora Serverless', 'Aurora Serverless'],
                  'DYNAMODB': ['Amazon DynamoDB', 'DynamoDB'],
                  'API_GATEWAY': ['Amazon API Gateway', 'API Gateway'],
                  'STEP_FUNCTIONS': ['AWS Step Functions', 'Step Functions'],
                  'SAM': ['AWS Serverless Application Model', 'SAM'],
                  'EVENTBRIDGE': ['Amazon EventBridge', 'EventBridge'],
                  'SNS': ['Amazon Simple Notification Service', 'SNS'],
                  'SQS': ['Amazon Simple Queue Service', 'SQS'],
                  'APP_RUNNER': ['AWS App Runner', 'App Runner'],

                  # Storage
                  'S3': ['Amazon Simple Storage Service', 'Amazon S3', 'S3'],
                  'S3_GLACIER': ['Amazon S3 Glacier', 'S3 Glacier', 'Glacier'],
                  'S3_GLACIER_DEEP_ARCHIVE': ['Amazon S3 Glacier Deep Archive', 'Glacier Deep Archive'],
                  'EBS': ['Amazon Elastic Block Store', 'Amazon EBS', 'EBS'],
                  'EFS': ['Amazon Elastic File System', 'Amazon EFS', 'EFS'],
                  'FSX': ['Amazon FSx', 'FSx'],
                  'FSX_LUSTRE': ['Amazon FSx for Lustre', 'FSx Lustre'],
                  'FSX_NETAPP': ['Amazon FSx for NetApp ONTAP', 'FSx NetApp'],
                  'FSX_WINDOWS': ['Amazon FSx for Windows File Server', 'FSx Windows'],
                  'FSX_OPENZFS': ['Amazon FSx for OpenZFS', 'FSx OpenZFS'],
                  'BACKUP': ['AWS Backup', 'Backup'],
                  'ELASTIC_DISASTER_RECOVERY': ['AWS Elastic Disaster Recovery', 'Elastic DR'],
                  'SNOW_FAMILY': ['AWS Snow Family', 'Snow Family'],
                  'SNOWBALL': ['AWS Snowball', 'Snowball'],
                  'SNOWBALL_EDGE': ['AWS Snowball Edge', 'Snowball Edge'],
                  'SNOWCONE': ['AWS Snowcone', 'Snowcone'],
                  'SNOWMOBILE': ['AWS Snowmobile', 'Snowmobile'],
                  'STORAGE_GATEWAY': ['AWS Storage Gateway', 'Storage Gateway'],

                  # VR & AR (Virtual & Augmented Reality)
                  'SUMERIAN': ['Amazon Sumerian', 'Sumerian'],

                  # Additional Services
                  'ANALYZER': ['AWS Analyzer', 'Analyzer'],
                  'BILLING': ['AWS Billing', 'Billing'],
                  'BLOCKCHAIN': ['Amazon Managed Blockchain', 'Blockchain'],
                  'CLOUD_DIRECTORY': ['Amazon Cloud Directory', 'Cloud Directory'],
                  'CODESTAR': ['AWS CodeStar', 'CodeStar'],
                  'DATA_LIFECYCLE_MANAGER': ['Amazon Data Lifecycle Manager', 'DLM'],
                  'DEVICE_FARM': ['AWS Device Farm', 'Device Farm'],
                  'IMPORT_EXPORT': ['AWS Import/Export', 'Import/Export'],
                  'IOT_THINGS_GRAPH': ['AWS IoT Things Graph', 'Things Graph'],
                  'MANAGED_SERVICES': ['AWS Managed Services', 'AMS'],
                  'MARKETPLACE': ['AWS Marketplace', 'Marketplace'],
                  'QUICKSIGHT': ['Amazon QuickSight', 'QuickSight'],
                  'RAM': ['AWS Resource Access Manager', 'RAM'],
                  'SERVICE_QUOTAS': ['Service Quotas'],
                  'SHIELD_ADVANCED': ['AWS Shield Advanced', 'Shield Advanced'],
                  'SUPPORT': ['AWS Support', 'Support'],
                  'SYSTEMS_MANAGER_SESSION_MANAGER': ['AWS Systems Manager Session Manager', 'Session Manager'],
                  'TAG_EDITOR': ['AWS Tag Editor', 'Tag Editor'],
                  'TRUSTED_ADVISOR': ['AWS Trusted Advisor', 'Trusted Advisor'],
                  'WAF_REGIONAL': ['AWS WAF Regional', 'WAF Regional']
                  }


          def match_service_names(service_input: str, service_mapping: Dict) -> List[str]:
              """
              Match input service name against the mapping and return all possible matches
              """
              matched_services = set()
              service_input = service_input.upper().strip()
              
              for key, variants in service_mapping.items():
                  # Check if input matches any variant
                  if any(service_input in variant.upper() for variant in variants):
                      matched_services.update(variants)
                  # Check if input is a partial match
                  elif any(re.search(service_input, variant.upper()) for variant in variants):
                      matched_services.update(variants)
              
              return list(matched_services)

          def validate_date_boundaries(start, end):
              """
              Validate date range without forcing month boundaries and adjust current month end date.
              """
              
              # If end date is the first day of a month, look at the previous day to determine the actual month we're analyzing
              actual_end = end - timedelta(days=1) if end.day == 1 else end
              
              # Check if actual end date is in current month
              today = datetime.now()
              
              # For historical cost analysis (non-forecast requests)
              if (actual_end.year == today.year and 
                  actual_end.month == today.month and 
                  actual_end > today):
                  end = today + timedelta(days=1)  # Add one day to make it inclusive
                  
              # Validate that end date is not beyond next month for historical data
              next_month = (today.replace(day=1) + timedelta(days=32)).replace(day=1)
              if end > next_month:
                  raise ValueError("End date cannot be beyond the beginning of next month for historical cost analysis")            
              return start, end


          def get_group_by_type(group_by_input):
              """
              Map various input formats to correct group by types
              """
              if not group_by_input:
                  return 'SERVICE'  # Default

              group_by_input = str(group_by_input).upper().replace(' ', '_')
              
              group_by_mapping = {
                  # Service mappings
                  'SERVICE': 'SERVICE',
                  'SERVICES': 'SERVICE',
                  'BY_SERVICE': 'SERVICE',
                  
                  # Usage type mappings
                  'USAGE': 'USAGE_TYPE',
                  'USAGE_TYPE': 'USAGE_TYPE',
                  'USAGETYPE': 'USAGE_TYPE',
                  'BY_USAGE': 'USAGE_TYPE',
                  'BY_USAGE_TYPE': 'USAGE_TYPE',
                  
                  # Linked account mappings
                  'ACCOUNT': 'LINKED_ACCOUNT',
                  'ACCOUNTS': 'LINKED_ACCOUNT',
                  'LINKED_ACCOUNT': 'LINKED_ACCOUNT',
                  'LINKEDACCOUNT': 'LINKED_ACCOUNT',
                  'BY_ACCOUNT': 'LINKED_ACCOUNT',
                  'BY_LINKED_ACCOUNT': 'LINKED_ACCOUNT',
                  'LINKED_ACCOUNTS': 'LINKED_ACCOUNT',
                  
                  # Region mappings
                  'REGION': 'REGION',
                  'REGIONS': 'REGION',
                  'BY_REGION': 'REGION',
                  
                  # Billing entity mappings
                  'BILLING': 'BILL_BILLING_ENTITY',
                  'BILLING_ENTITY': 'BILL_BILLING_ENTITY',
                  'BILLINGENTITY': 'BILL_BILLING_ENTITY',
                  'BY_BILLING': 'BILL_BILLING_ENTITY',
                  'BY_BILLING_ENTITY': 'BILL_BILLING_ENTITY'
              }
              
              return group_by_mapping.get(group_by_input, 'SERVICE')

          def get_cost_data_with_retry(client, **kwargs):
              """Execute Cost Explorer API call with retry logic."""
              max_retries = 3
              retry_delay = 1  # seconds
              
              for attempt in range(max_retries):
                  try:
                      return client.get_cost_and_usage(**kwargs)
                  except ClientError as e:
                      if e.response['Error']['Code'] == 'ThrottlingException':
                          if attempt < max_retries - 1:
                              time.sleep(retry_delay * (2 ** attempt))
                              continue
                      elif e.response['Error']['Code'] == 'ValidationException':
                          error_message = str(e)
                          if 'historical data beyond' in error_message:
                              # Handle historical data limitation gracefully
                              raise ValueError("You haven't enabled historical data beyond 14 months.")
                          elif 'end date past the beginning of next month' in error_message:
                              # Handle future date limitation
                              raise ValueError("End date cannot be beyond the beginning of next month")
                      raise


          def process_monthly_data(result, group_by_key):
              """Process and validate monthly cost data with exact decimal precision."""
              try:
                  time_period = {
                      'start': result['TimePeriod']['Start'],
                      'end': result['TimePeriod']['End']
                  }

                  if not result['Groups']:
                      print(f"Warning: No data for period {time_period['start']} to {time_period['end']}")
                      return None
                  
                  all_items = []
                  running_total = Decimal('0')
                  for group in result['Groups']:
                      item_name = group['Keys'][0]
                      amount = Decimal(group['Metrics']['UnblendedCost']['Amount'])
                      running_total += amount
                      display_amount = amount.quantize(Decimal('0.01'))
                      unit = group['Metrics']['UnblendedCost']['Unit']
                      all_items.append({
                          'name': item_name,
                          'amount': str(display_amount),
                          'unit': unit
                      })
                          
                  # Calculate total cost with 2 decimal places
                  total_cost = running_total.quantize(Decimal('0.01'))
                  
                  return {
                      'time_period': time_period,
                      'total_cost': {
                          'amount': str(total_cost), 
                          'unit': 'USD'
                      },
                      'group_by': group_by_key,
                      'items': all_items
                  }
              except Exception as e:
                  print(f"Error processing month {time_period['start'] if 'time_period' in locals() else 'unknown'}: {str(e)}")
                  return None

          def get_cost_and_usage(start_date, end_date, group_by=None, granularity='MONTHLY'):
              """Main function to retrieve cost and usage data."""
              client = boto3.client('ce')
              cost_data = []
              next_token = None
              period_total = Decimal('0.00')  # Initialize period total
              
              # Set default group_by to SERVICE if not specified
              if not group_by:
                  group_by = 'SERVICE'
              
              # Validate and map group_by parameter
              valid_group_by = {
                  'SERVICE': 'SERVICE',
                  'USAGE_TYPE': 'USAGE_TYPE',
                  'LINKED_ACCOUNT': 'LINKED_ACCOUNT',
                  'REGION': 'REGION',
                  'BILLING_ENTITY': 'BILL_BILLING_ENTITY'
              }
              
              group_by_key = valid_group_by.get(group_by.upper(), 'SERVICE')
              
              # Validate granularity
              valid_granularity = {'DAILY', 'MONTHLY', 'YEARLY'}
              if granularity.upper() not in valid_granularity:
                  granularity = 'MONTHLY'
              
              while True:
                  kwargs = {
                      'TimePeriod': {
                          'Start': start_date.strftime('%Y-%m-%d'),
                          'End': end_date.strftime('%Y-%m-%d')
                      },
                      'Granularity': granularity.upper(),
                      'Metrics': ['UnblendedCost'],
                      'GroupBy': [                    
                          {'Type': 'DIMENSION', 'Key': group_by_key}
                      ]
                  }
                  
                  if next_token:
                      kwargs['NextPageToken'] = next_token
                  
                  try:
                      response = get_cost_data_with_retry(client, **kwargs)
                      print(f"API Response: {json.dumps(response)}")
                      
                      # Create a list to store all items across all periods
                      all_items_together = []
                      
                      for result in response['ResultsByTime']:
                          monthly_data = process_monthly_data(result, group_by_key)
                          if monthly_data:
                              cost_data.append(monthly_data)
                              # Add all items to the consolidated list
                              all_items_together.extend(monthly_data['items'])
                              # Add to period total
                              period_total += Decimal(monthly_data['total_cost']['amount'])

                      # Create a dictionary to combine costs for similar services
                      combined_costs = {}
                      for item in all_items_together:
                          item_name = item['name']
                          item_amount = Decimal(item['amount'])
                          
                          if item_name in combined_costs:
                              combined_costs[item_name]['amount'] += item_amount
                          else:
                              combined_costs[item_name] = {
                                  'name': item_name,
                                  'amount': item_amount,
                                  'unit': item['unit']
                              }

                      # Convert combined costs to list and format amounts
                      all_combined_items = []
                      for service_data in combined_costs.values():
                          all_combined_items.append({
                              'name': service_data['name'],
                              'amount': str(service_data['amount'].quantize(Decimal('0.01'))),
                              'unit': service_data['unit']
                          })

                      # Sort combined items by cost (descending) and get top 10
                      top_10_services = sorted(
                          all_combined_items,
                          key=lambda x: Decimal(x['amount']),
                          reverse=True
                      )[:10]
                      
                      if 'NextPageToken' not in response:
                          break
                      next_token = response['NextPageToken']

                  except ValueError as ve:
                      # Handle the specific historical data limitation error
                      return {
                          'period_total': {'amount': '0', 'unit': 'USD'},
                          'period': {
                              'start': start_date.strftime('%Y-%m-%d'),
                              'end': end_date.strftime('%Y-%m-%d')
                          },
                          'granularity': granularity,
                          'top_10_services': [],
                          'detailed_data': [],
                          'error_message': str(ve)
                      }

                  except Exception as e:
                      print(f"Error in cost explorer API call: {str(e)}")
                      raise
              
              period_total = period_total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

              return {
                  'period_total': {
                      'amount': str(period_total),
                      'unit': 'USD'
                  },
                  'period': {
                      'start': start_date.strftime('%Y-%m-%d'),
                      'end': end_date.strftime('%Y-%m-%d')
                  },
                  'granularity': granularity,
                  'top_10_services': top_10_services,
                  'detailed_data': cost_data
              }
          def get_service_specific_costs(start_date: datetime, 
                                      end_date: datetime, 
                                      services: Union[str, List[str]], 
                                      granularity: str = 'MONTHLY',
                                      display_start_date = 'default',
                                      display_end_date = 'default',
                                      api_path: str = '',
                                      action_group: str = '') -> Dict:
              """
              Get costs for specific AWS services
              """
              try:
                  client = boto3.client('ce')
                  
                  # Convert single service to list
                  if isinstance(services, str):
                      services = [services]
                  
                  # Get service mapping
                  service_mapping = get_aws_service_mapping()
                  
                  # Find all matching services
                  matched_services = set()
                  for service in services:
                      matched = match_service_names(service, service_mapping)
                      matched_services.update(matched)
                  
                  if not matched_services:
                      return format_response(400, {
                          "message": f"No matching AWS services found for: {', '.join(services)}",
                          "suggestions": "Please try with a valid AWS service name"
                      }, action_group, f"{api_path}") 
                  
                  # Prepare filters for CE API
                  filters = {
                      'Dimensions': {
                          'Key': 'SERVICE',
                          'Values': list(matched_services)
                      }
                  }
                  
                  kwargs = {
                      'TimePeriod': {
                          'Start': start_date.strftime('%Y-%m-%d'),
                          'End': end_date.strftime('%Y-%m-%d')
                      },
                      'Granularity': granularity,
                      'Metrics': ['UnblendedCost'],
                      'GroupBy': [
                          {'Type': 'DIMENSION', 'Key': 'SERVICE'}
                      ],
                      'Filter': filters
                  }
                  
                  cost_data = []
                  next_token = None
                  total_cost = Decimal('0')
                  service_totals = {}
                  
                  while True:
                      if next_token:
                          kwargs['NextPageToken'] = next_token
                      
                      response = get_cost_data_with_retry(client, **kwargs)
                      
                      for result in response['ResultsByTime']:
                          monthly_data = process_monthly_data(result, 'SERVICE')
                          if monthly_data:
                              cost_data.append(monthly_data)
                              
                              # Update service-specific totals
                              for item in monthly_data['items']:
                                  service_name = item['name']
                                  amount = Decimal(item['amount'])
                                  if service_name in service_totals:
                                      service_totals[service_name] += amount
                                  else:
                                      service_totals[service_name] = amount
                                  total_cost += amount
                      
                      if 'NextPageToken' not in response:
                          break
                      next_token = response['NextPageToken']
                  
                  # Format service totals
                  formatted_service_totals = []
                  for service, amount in service_totals.items():
                      formatted_service_totals.append({
                          'service': service,
                          'total_cost': {
                              'amount': str(amount.quantize(Decimal('0.01'))),
                              'unit': 'USD'
                          }
                      })
                  
                  # Sort services by cost
                  formatted_service_totals.sort(key=lambda x: Decimal(x['total_cost']['amount']), reverse=True)
                  
                  return format_response(200, {
                      "message": f"Cost analysis for services: {', '.join(matched_services)}",
                      "period": {
                          "start": display_start_date,
                          "end": display_end_date
                      },
                      "total_cost": {
                          "amount": str(total_cost.quantize(Decimal('0.01'))),
                          "unit": "USD"
                      },
                      "service_totals": formatted_service_totals,
                      "monthly_breakdown": cost_data
                  }, action_group, "/get_service_costs") 

              except ValueError as ve:
                  # Handle the specific historical data limitation error
                  return format_response(400, {
                      "message": str(ve),
                      "period": {
                          "start": display_start_date,
                          "end": display_end_date
                      },
                      "total_cost": {
                          "amount": "0",
                          "unit": "USD"
                      },
                      "service_totals": [],
                      "monthly_breakdown": []
                  }, action_group, "/get_service_costs")

              except Exception as e:
                  print(f"Error in get_service_specific_costs: {str(e)}")
                  print("Traceback:", traceback.format_exc())
                  return format_response(500, f"Error processing request: {str(e)}", action_group, f"{api_path}")

          def format_response(status_code, body, action_group="", api_path=""):
              """Format the API response."""
              response = {
                  "messageVersion": "1.0",
                  "response": {
                      "actionGroup": action_group,
                      "apiPath": api_path,
                      "httpMethod": "POST",
                      "httpStatusCode": status_code,
                      "responseBody": {
                          "application/json": {
                              "body": body
                          }
                      }
                  }
              }
              print("Formatted response:", json.dumps(response))
              return response

          def lambda_handler(event, context):
              """Main Lambda handler."""
              try:
                  print("Received event:", json.dumps(event))
                  
                  agent = event.get('agent', {})
                  action_group = event.get('actionGroup', '')
                  print(f"Extracted actionGroup: '{action_group}'")  # Debug logging
                  api_path = event.get('apiPath', '')

                  function = event.get('apiPath', '').lstrip('/')
                  
                  # Extract parameters
                  parameters_dict = {}
                  if 'parameters' in event:
                      for param in event['parameters']:
                          parameters_dict[param['name']] = param['value']
                  
                  start_date = parameters_dict.get('start_date')
                  end_date = parameters_dict.get('end_date')

                  # if date in "mm/dd/yyyy" format then convert it to "yyyy-mm-dd"
                  if start_date and '/' in start_date and len(start_date.split('/')) == 3:
                      start_date = datetime.strptime(start_date, '%m/%d/%Y').strftime('%Y-%m-%d')
                      print("start_date:", start_date)  # Add this log
                  if end_date and '/' in end_date and len(end_date.split('/')) == 3:
                      end_date = datetime.strptime(end_date, '%m/%d/%Y').strftime('%Y-%m-%d')
                      print("end_date:", end_date)      # Add this log

                  print("Received start_date:", start_date)  # Add this log
                  print("Received end_date:", end_date)      # Add this log
                  
                  # Passing the actual date back from the function
                  display_start_date = start_date
                  display_end_date = end_date
                  
                  # Get and normalize group_by parameter
                  group_by_input = parameters_dict.get('group_by', '')
                  group_by = get_group_by_type(group_by_input)
                  
                  granularity = parameters_dict.get('granularity', 'MONTHLY')
                  
                  # Handle dates
                  if not start_date and not end_date:
                      end = datetime.now()
                      start = end - timedelta(days=365)
                  else:
                      try:
                          if end_date:
                              end = datetime.strptime(end_date, '%Y-%m-%d') + timedelta(days=1)
                          else:
                              end = datetime.now()
                          
                          if start_date:
                              start = datetime.strptime(start_date, '%Y-%m-%d')
                          else:
                              start = end - timedelta(days=365)
                      except ValueError as e:
                          return format_response(400, f"Invalid date format. Use YYYY-MM-DD. Error: {str(e)}", 
                                              action_group, f"/{function}")
                  

                  # Validate and adjust date boundaries based on whether it's a forecast request
                  try:
                      start, end = validate_date_boundaries(start, end)
                  except ValueError as ve:
                      return format_response(400, {
                          "message": str(ve),
                          "period": {
                              "start": display_start_date,
                              "end": display_end_date
                          }
                      }, action_group, f"/{function}")

                  print("endDate:", end)

                  if function == 'get_cost_and_usage':
                      try:
                          cost_data = get_cost_and_usage(start, end, group_by, granularity)
                          
                          # Check if there's an error message in the response
                          if isinstance(cost_data, dict) and 'error_message' in cost_data:
                              return format_response(400, {
                                  "message": cost_data['error_message'],
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  },
                                  "granularity": granularity
                              }, action_group, "/get_cost_and_usage")

                          group_by_display = {
                              'SERVICE': 'services',
                              'USAGE_TYPE': 'usage types',
                              'LINKED_ACCOUNT': 'linked accounts',
                              'REGION': 'regions',
                              'BILL_BILLING_ENTITY': 'billing entities'
                          }.get(group_by.upper() if group_by else 'SERVICE', 'services')
                          
                          return format_response(200, {
                              "message": f"Showing top 10 most expensive {group_by_display} and total cost",
                              "granularity": granularity,
                              "period_total": cost_data['period_total'],
                              #"period": cost_data['period'],
                              "period": {
                                  "start": display_start_date,
                                  "end": display_end_date
                              },
                              "top_10_services": cost_data['top_10_services'],
                              "data": cost_data['detailed_data']
                          }, action_group, "/get_cost_and_usage")
                          
                      except Exception as e:
                          print(f"Error in get_cost_and_usage: {str(e)}")
                          error_message = str(e)
                          if "historical data beyond" in error_message:
                              return format_response(400, {
                                  "message": "You haven't enabled historical data beyond 14 months",
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  }
                              }, action_group, "/get_cost_and_usage")
                          elif "end date past the beginning of next month" in error_message:
                              return format_response(400, {
                                  "message": "End date cannot be beyond the beginning of next month",
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  }
                              }, action_group, "/get_cost_and_usage")
                          return format_response(500, f"Error processing request: {error_message}", 
                                              action_group, "/get_cost_and_usage")

                  
                  elif function == 'get_service_costs':
                      # Extract service names from parameters
                      services = parameters_dict.get('services', '').split(',')
                      services = [s.strip() for s in services if s.strip()]
                      
                      if not services:
                          return format_response(400, "No services specified", 
                                              action_group, "/get_service_costs")
                      
                      try:
                          result = get_service_specific_costs(start, end, services, granularity, display_start_date, display_end_date, api_path, action_group)
                          # Ensure the action_group is correctly set in the response
                          if isinstance(result, dict) and 'error_message' in result:
                              return format_response(400, {
                                  "message": result['error_message'],
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  }
                              }, action_group, "/get_service_costs")
                          return result
                      except Exception as e:
                          error_message = str(e)
                          if "historical data beyond" in error_message:
                              return format_response(400, {
                                  "message": "You haven't enabled historical data beyond 14 months",
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  }
                              }, action_group, "/get_service_costs")
                          elif "end date past the beginning of next month" in error_message:
                              return format_response(400, {
                                  "message": "End date cannot be beyond the beginning of next month for historical cost analysis",
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  }
                              }, action_group, "/get_service_costs")
                          return format_response(500, f"Error processing request: {error_message}", 
                                              action_group, "/get_service_costs")

                      
                  else:
                      return format_response(404, f"Function not found: {function}", 
                                          action_group, f"/{function}")

              except Exception as e:
                  print(f"Unexpected error in lambda_handler: {str(e)}")
                  print("Traceback:", traceback.format_exc())
                  return format_response(500, f"Unexpected error: {str(e)}", 
                                      event.get('actionGroup', ''), event.get('apiPath', ''))


      Description: 'Lambda function to get cost from cost explorer'
      Timeout: 900
      MemorySize: 1024

  # Lambda Function 4: Get-Cost-Forecast-From-Cost-Explorer
  CostForecast:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CostForecast
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.13
      Code:
        ZipFile: |
          import boto3
          from datetime import datetime, timedelta
          import json
          import traceback
          from botocore.exceptions import ClientError
          import time
          from decimal import Decimal, ROUND_HALF_UP, ROUND_UP
          import re
          from typing import List, Dict, Union, Any

          def get_aws_service_mapping():
              """
              Returns a dictionary mapping common service names/aliases to their official AWS service names
              """
              return {
                  # Analytics
                  'ATHENA': ['Amazon Athena', 'Athena'],
                  'CLOUDSEARCH': ['Amazon CloudSearch', 'CloudSearch'],
                  'DATAZONE': ['Amazon DataZone', 'DataZone'],
                  'EMR': ['Amazon EMR', 'EMR', 'Elastic MapReduce'],
                  'EMR_SERVERLESS': ['Amazon EMR Serverless', 'EMR Serverless'],
                  'FINSPACE': ['Amazon FinSpace', 'FinSpace'],
                  'KINESIS': ['Amazon Kinesis', 'Kinesis'],
                  'KINESIS_DATA_ANALYTICS': ['Amazon Kinesis Data Analytics', 'Kinesis Analytics'],
                  'KINESIS_DATA_FIREHOSE': ['Amazon Kinesis Data Firehose', 'Kinesis Firehose'],
                  'KINESIS_DATA_STREAMS': ['Amazon Kinesis Data Streams', 'Kinesis Streams'],
                  'KINESIS_VIDEO_STREAMS': ['Amazon Kinesis Video Streams', 'Kinesis Video'],
                  'LAKE_FORMATION': ['AWS Lake Formation', 'Lake Formation'],
                  'MANAGED_STREAMING_APACHE_KAFKA': ['Amazon Managed Streaming for Apache Kafka', 'Amazon MSK', 'MSK'],
                  'OPENSEARCH': ['Amazon OpenSearch Service', 'OpenSearch', 'Amazon OpenSearch'],
                  'QUICKSIGHT': ['Amazon QuickSight', 'QuickSight'],
                  'REDSHIFT': ['Amazon Redshift', 'Redshift'],
                  'GLUE': ['AWS Glue', 'Glue'],
                  'CLEAN_ROOMS': ['AWS Clean Rooms', 'Clean Rooms'],
                  'DATA_EXCHANGE': ['AWS Data Exchange', 'Data Exchange'],
                  'DATA_PIPELINE': ['AWS Data Pipeline', 'Data Pipeline'],

                  # Application Integration
                  'API_GATEWAY': ['Amazon API Gateway', 'API Gateway', 'APIGateway'],
                  'APPFLOW': ['Amazon AppFlow', 'AppFlow'],
                  'EVENTBRIDGE': ['Amazon EventBridge', 'EventBridge', 'CloudWatch Events'],
                  'MANAGED_WORKFLOWS_APACHE_AIRFLOW': ['Amazon Managed Workflows for Apache Airflow', 'MWAA', 'Managed Airflow'],
                  'MQ': ['Amazon MQ', 'MQ'],
                  'SNS': ['Amazon Simple Notification Service', 'Amazon SNS', 'SNS'],
                  'SQS': ['Amazon Simple Queue Service', 'Amazon SQS', 'SQS'],
                  'APP_SYNC': ['AWS AppSync', 'AppSync'],
                  'CONSOLE_MOBILE_APPLICATION': ['AWS Console Mobile Application', 'Console Mobile App'],
                  'EXPRESS_WORKFLOWS': ['AWS Express Workflows', 'Express Workflows'],
                  'STEP_FUNCTIONS': ['AWS Step Functions', 'Step Functions', 'StepFunctions'],
                  'MICROSERVICE_EXTRACTOR': ['AWS Microservice Extractor for .NET', 'Microservice Extractor'],

                  # AWS Cost Management
                  'APPLICATION_COST_PROFILER': ['AWS Application Cost Profiler', 'Cost Profiler'],
                  'BILLING_CONDUCTOR': ['AWS Billing Conductor', 'Billing Conductor'],
                  'BUDGETS': ['AWS Budgets', 'Budgets'],
                  'COST_EXPLORER': ['AWS Cost Explorer', 'Cost Explorer'],
                  'COST_AND_USAGE_REPORT': ['AWS Cost and Usage Report', 'CUR', 'Cost and Usage Report'],
                  'RESERVED_INSTANCE_REPORTING': ['Reserved Instance Reporting', 'RI Reporting'],
                  'SAVINGS_PLANS': ['Savings Plans'],

                  # Blockchain
                  'MANAGED_BLOCKCHAIN': ['Amazon Managed Blockchain', 'Managed Blockchain'],
                  'QUANTUM_LEDGER_DATABASE': ['Amazon Quantum Ledger Database', 'QLDB'],

                  # Business Applications
                  'ALEXA_FOR_BUSINESS': ['Alexa for Business', 'A4B'],
                  'CHIME': ['Amazon Chime', 'Chime'],
                  'CHIME_SDK': ['Amazon Chime SDK', 'Chime SDK'],
                  'CONNECT': ['Amazon Connect', 'Connect'],
                  'HONEYCODE': ['Amazon Honeycode', 'Honeycode'],
                  'PINPOINT': ['Amazon Pinpoint', 'Pinpoint'],
                  'PINPOINT_SMS_VOICE': ['Amazon Pinpoint SMS and Voice', 'Pinpoint SMS', 'Pinpoint Voice'],
                  'SIMPLE_EMAIL_SERVICE': ['Amazon Simple Email Service', 'Amazon SES', 'SES'],
                  'WORKDOCS': ['Amazon WorkDocs', 'WorkDocs'],
                  'WORKMAIL': ['Amazon WorkMail', 'WorkMail'],
                  'SUPPLY_CHAIN': ['AWS Supply Chain', 'Supply Chain'],
                  'WICKR': ['AWS Wickr', 'Wickr'],
                  'PRIVATE_5G': ['AWS Private 5G', 'Private 5G'],

                  # Compute
                  'EC2': ['Amazon Elastic Compute Cloud', 'Amazon EC2', 'EC2', 'AWS EC2'],
                  'EC2_AUTO_SCALING': ['Amazon EC2 Auto Scaling', 'Auto Scaling', 'ASG'],
                  'EC2_SPOT_INSTANCES': ['Amazon EC2 Spot Instances', 'EC2 Spot', 'Spot Instances'],
                  'EC2_IMAGE_BUILDER': ['Amazon EC2 Image Builder', 'EC2 Image Builder', 'Image Builder'],
                  'LIGHTSAIL': ['Amazon Lightsail', 'Lightsail'],
                  'APP_RUNNER': ['AWS App Runner', 'App Runner'],
                  'BATCH': ['AWS Batch', 'Batch'],
                  'COMPUTE_OPTIMIZER': ['AWS Compute Optimizer', 'Compute Optimizer'],
                  'ELASTIC_BEANSTALK': ['AWS Elastic Beanstalk', 'Elastic Beanstalk', 'Beanstalk'],
                  'LAMBDA': ['AWS Lambda', 'Lambda', 'AWS Lambda Function'],
                  'LOCAL_ZONES': ['AWS Local Zones', 'Local Zones'],
                  'NITRO_ENCLAVES': ['AWS Nitro Enclaves', 'Nitro Enclaves'],
                  'OUTPOSTS': ['AWS Outposts', 'Outposts'],
                  'PARALLEL_CLUSTER': ['AWS ParallelCluster', 'ParallelCluster'],
                  'SERVERLESS_APPLICATION_REPOSITORY': ['AWS Serverless Application Repository', 'SAR', 'Serverless Repo'],
                  'SIMSPACE_WEAVER': ['AWS SimSpace Weaver', 'SimSpace Weaver'],
                  'THINKBOX_DEADLINE': ['AWS Thinkbox Deadline', 'Deadline'],
                  'THINKBOX_FROST': ['AWS Thinkbox Frost', 'Frost'],
                  'THINKBOX_KRAKATOA': ['AWS Thinkbox Krakatoa', 'Krakatoa'],
                  'THINKBOX_SEQUOIA': ['AWS Thinkbox Sequoia', 'Sequoia'],
                  'THINKBOX_STOKE': ['AWS Thinkbox Stoke', 'Stoke'],
                  'THINKBOX_XMESH': ['AWS Thinkbox XMesh', 'XMesh'],
                  'WAVELENGTH': ['AWS Wavelength', 'Wavelength'],
                  'BOTTLEROCKET': ['Bottlerocket'],
                  'NICE_DCV': ['NICE DCV'],
                  'VMWARE_CLOUD': ['VMware Cloud on AWS', 'VMware Cloud'],

                  # Containers
                  'ECR': ['Amazon Elastic Container Registry', 'Amazon ECR', 'ECR'],
                  'ECR_PUBLIC': ['Amazon Elastic Container Registry Public', 'Amazon ECR Public', 'ECR Public'],
                  'ECS': ['Amazon Elastic Container Service', 'Amazon ECS', 'ECS'],
                  'EKS': ['Amazon Elastic Kubernetes Service', 'Amazon EKS', 'EKS'],
                  'EKS_ANYWHERE': ['Amazon EKS Anywhere', 'EKS Anywhere'],
                  'EKS_DISTRO': ['Amazon EKS Distro', 'EKS Distro'],
                  'APP2CONTAINER': ['AWS App2Container', 'App2Container', 'A2C'],
                  'COPILOT': ['AWS Copilot', 'Copilot'],
                  'FARGATE': ['AWS Fargate', 'Fargate'],
                  'RED_HAT_OPENSHIFT': ['Red Hat OpenShift Service on AWS', 'ROSA', 'OpenShift'],

                  # Database
                  'AURORA': ['Amazon Aurora', 'Aurora'],
                  'DOCUMENTDB': ['Amazon DocumentDB', 'DocumentDB'],
                  'DYNAMODB': ['Amazon DynamoDB', 'DynamoDB'],
                  'ELASTICACHE': ['Amazon ElastiCache', 'ElastiCache'],
                  'KEYSPACES': ['Amazon Keyspaces', 'Keyspaces'],
                  'MEMORYDB': ['Amazon MemoryDB for Redis', 'MemoryDB'],
                  'NEPTUNE': ['Amazon Neptune', 'Neptune'],
                  'RDS': ['Amazon Relational Database Service', 'Amazon RDS', 'RDS'],
                  'TIMESTREAM': ['Amazon Timestream', 'Timestream'],
                  'DATABASE_MIGRATION_SERVICE': ['AWS Database Migration Service', 'DMS', 'Database Migration'],

                  # Developer Tools
                  'CLOUD9': ['AWS Cloud9', 'Cloud9'],
                  'CLOUD_CONTROL_API': ['AWS Cloud Control API', 'Cloud Control'],
                  'CLOUDSHELL': ['AWS CloudShell', 'CloudShell'],
                  'CODECATALYST': ['Amazon CodeCatalyst', 'CodeCatalyst'],
                  'CODEARTIFACT': ['AWS CodeArtifact', 'CodeArtifact'],
                  'CODEBUILD': ['AWS CodeBuild', 'CodeBuild'],
                  'CODECOMMIT': ['AWS CodeCommit', 'CodeCommit'],
                  'CODEDEPLOY': ['AWS CodeDeploy', 'CodeDeploy'],
                  'CODEGURU': ['Amazon CodeGuru', 'CodeGuru'],
                  'CODEGURU_PROFILER': ['Amazon CodeGuru Profiler', 'CodeGuru Profiler'],
                  'CODEGURU_REVIEWER': ['Amazon CodeGuru Reviewer', 'CodeGuru Reviewer'],
                  'CODEPIPELINE': ['AWS CodePipeline', 'CodePipeline'],
                  'CODESTAR': ['AWS CodeStar', 'CodeStar'],
                  'CODESTAR_CONNECTIONS': ['AWS CodeStar Connections', 'CodeStar Connections'],
                  'CODESTAR_NOTIFICATIONS': ['AWS CodeStar Notifications', 'CodeStar Notifications'],
                  'COMMAND_LINE_INTERFACE': ['AWS Command Line Interface', 'AWS CLI', 'CLI'],
                  'CORRETTO': ['Amazon Corretto', 'Corretto'],
                  'FAULT_INJECTION_SIMULATOR': ['AWS Fault Injection Simulator', 'FIS'],
                  'TOOLS_AND_SDKS': ['AWS Tools and SDKs', 'SDKs'],
                  'X_RAY': ['AWS X-Ray', 'X-Ray'],

                  # End User Computing
                  'APPSTREAM': ['Amazon AppStream 2.0', 'AppStream'],
                  'WORKSPACES': ['Amazon WorkSpaces', 'WorkSpaces'],
                  'WORKSPACES_WEB': ['Amazon WorkSpaces Web', 'WorkSpaces Web'],
                  'WORKSPACES_APPLICATION_MANAGER': ['AWS WAM', 'WAM'],

                  # Frontend Web & Mobile
                  'AMPLIFY': ['AWS Amplify', 'Amplify'],
                  'DEVICE_FARM': ['AWS Device Farm', 'Device Farm'],
                  'LOCATION': ['Amazon Location Service', 'Location Service'],

                  # Game Development
                  'GAMELIFT': ['Amazon GameLift', 'GameLift'],
                  'OPEN_3D_ENGINE': ['Open 3D Engine', 'O3DE'],

                  # Internet of Things (IoT)
                  'FORECASTCLI': ['Amazon ForecastCLI', 'ForecastCLI'],
                  'IOT_1_CLICK': ['AWS IoT 1-Click', 'IoT 1-Click'],
                  'IOT_ANALYTICS': ['AWS IoT Analytics', 'IoT Analytics'],
                  'IOT_CORE': ['AWS IoT Core', 'IoT Core'],
                  'IOT_DEVICE_DEFENDER': ['AWS IoT Device Defender', 'IoT Device Defender'],
                  'IOT_DEVICE_MANAGEMENT': ['AWS IoT Device Management', 'IoT Device Management'],
                  'IOT_EVENTS': ['AWS IoT Events', 'IoT Events'],
                  'IOT_FLEETHUB': ['AWS IoT FleetHub', 'IoT FleetHub'],
                  'IOT_GREENGRASS': ['AWS IoT Greengrass', 'Greengrass'],
                  'IOT_ROBORUNNER': ['AWS IoT RoboRunner', 'RoboRunner'],
                  'IOT_SITEWISE': ['AWS IoT SiteWise', 'SiteWise'],
                  'IOT_TWINMAKER': ['AWS IoT TwinMaker', 'TwinMaker'],
                  'IOT_WIRELESS': ['AWS IoT Wireless', 'IoT Wireless'],
                  'MONITRON': ['Amazon Monitron', 'Monitron'],

                  # Machine Learning & AI
                  'BEDROCK': ['Amazon Bedrock', 'Bedrock'],
                  'COMPREHEND': ['Amazon Comprehend', 'Comprehend'],
                  'CODEWHISPERER': ['Amazon CodeWhisperer', 'CodeWhisperer'],
                  'DEVOPS_GURU': ['Amazon DevOps Guru', 'DevOps Guru'],
                  'ELASTIC_INFERENCE': ['Amazon Elastic Inference', 'Elastic Inference'],
                  'FORECAST': ['Amazon Forecast', 'Forecast'],
                  'FRAUD_DETECTOR': ['Amazon Fraud Detector', 'Fraud Detector'],
                  'HEALTHLAKE': ['Amazon HealthLake', 'HealthLake'],
                  'KENDRA': ['Amazon Kendra', 'Kendra'],
                  'KEYSPHRASES': ['Amazon KeyPhrases', 'KeyPhrases'],
                  'LEX': ['Amazon Lex', 'Lex'],
                  'LOOKOUT_FOR_EQUIPMENT': ['Amazon Lookout for Equipment', 'Lookout Equipment'],
                  'LOOKOUT_FOR_METRICS': ['Amazon Lookout for Metrics', 'Lookout Metrics'],
                  'LOOKOUT_FOR_VISION': ['Amazon Lookout for Vision', 'Lookout Vision'],
                  'MONITRON': ['Amazon Monitron', 'Monitron'],
                  'OMICS': ['Amazon Omics', 'Omics'],
                  'PERSONALIZE': ['Amazon Personalize', 'Personalize'],
                  'POLLY': ['Amazon Polly', 'Polly'],
                  'REKOGNITION': ['Amazon Rekognition', 'Rekognition'],
                  'SAGEMAKER': ['Amazon SageMaker', 'SageMaker'],
                  'SAGEMAKER_GROUND_TRUTH': ['Amazon SageMaker Ground Truth', 'Ground Truth'],
                  'TEXTRACT': ['Amazon Textract', 'Textract'],
                  'TRANSCRIBE': ['Amazon Transcribe', 'Transcribe'],
                  'TRANSLATE': ['Amazon Translate', 'Translate'],
                  'AUGMENTED_AI': ['Amazon Augmented AI', 'A2I'],
                  'DEEP_LEARNING_AMIS': ['AWS Deep Learning AMIs', 'Deep Learning AMIs'],
                  'DEEP_LEARNING_CONTAINERS': ['AWS Deep Learning Containers', 'Deep Learning Containers'],
                  'DEEPCOMPOSER': ['AWS DeepComposer', 'DeepComposer'],
                  'DEEPLENS': ['AWS DeepLens', 'DeepLens'],
                  'DEEPRACER': ['AWS DeepRacer', 'DeepRacer'],
                  'NEURON': ['AWS Neuron', 'Neuron'],
                  'PANORAMA': ['AWS Panorama', 'Panorama'],
                  'TENSORFLOW_ON_AWS': ['TensorFlow on AWS', 'TensorFlow'],

                  # Management & Governance
                  'APPLICATION_AUTO_SCALING': ['Application Auto Scaling'],
                  'CHATBOT': ['AWS Chatbot', 'Chatbot'],
                  'CLOUDFORMATION': ['AWS CloudFormation', 'CloudFormation'],
                  'CLOUDTRAIL': ['AWS CloudTrail', 'CloudTrail', 'Cloud Trail'],
                  'CLOUDWATCH': ['Amazon CloudWatch', 'CloudWatch'],
                  'CLOUDWATCH_LOGS': ['Amazon CloudWatch Logs', 'CloudWatch Logs'],
                  'CLOUDWATCH_METRICS': ['Amazon CloudWatch Metrics', 'CloudWatch Metrics'],
                  'CONFIG': ['AWS Config', 'Config'],
                  'CONTROL_TOWER': ['AWS Control Tower', 'Control Tower'],
                  'DISTRO_FOR_OPENTELEMETRY': ['AWS Distro for OpenTelemetry', 'OpenTelemetry'],
                  'FAULT_INJECTION_SIMULATOR': ['AWS Fault Injection Simulator', 'FIS'],
                  'HEALTH_DASHBOARD': ['AWS Health Dashboard', 'Health Dashboard'],
                  'LICENSE_MANAGER': ['AWS License Manager', 'License Manager'],
                  'MANAGED_GRAFANA': ['Amazon Managed Grafana', 'Managed Grafana'],
                  'MANAGED_SERVICE_FOR_PROMETHEUS': ['Amazon Managed Service for Prometheus', 'Managed Prometheus'],
                  'MANAGEMENT_CONSOLE': ['AWS Management Console', 'Management Console'],
                  'OPS_WORKS': ['AWS OpsWorks', 'OpsWorks'],
                  'ORGANIZATIONS': ['AWS Organizations', 'Organizations'],
                  'PERSONAL_HEALTH_DASHBOARD': ['AWS Personal Health Dashboard', 'Personal Health'],
                  'PROTON': ['AWS Proton', 'Proton'],
                  'RESILIENCE_HUB': ['AWS Resilience Hub', 'Resilience Hub'],
                  'RESOURCE_EXPLORER': ['AWS Resource Explorer', 'Resource Explorer'],
                  'SERVICE_CATALOG': ['AWS Service Catalog', 'Service Catalog'],
                  'SERVICE_MANAGEMENT_CONNECTOR': ['AWS Service Management Connector', 'Service Management'],
                  'SYSTEMS_MANAGER': ['AWS Systems Manager', 'Systems Manager', 'SSM'],
                  'TRUSTED_ADVISOR': ['AWS Trusted Advisor', 'Trusted Advisor'],
                  'WELL_ARCHITECTED_TOOL': ['AWS Well-Architected Tool', 'Well-Architected'],

                  # Media Services
                  'ELASTIC_TRANSCODER': ['Amazon Elastic Transcoder', 'Elastic Transcoder'],
                  'ELEMENTAL_APPLIANCES_SOFTWARE': ['AWS Elemental Appliances and Software', 'Elemental'],
                  'ELEMENTAL_CONDUCTOR': ['AWS Elemental Conductor', 'Conductor'],
                  'ELEMENTAL_DELTA': ['AWS Elemental Delta', 'Delta'],
                  'ELEMENTAL_LINK': ['AWS Elemental Link', 'Elemental Link'],
                  'ELEMENTAL_LIVE': ['AWS Elemental Live', 'Elemental Live'],
                  'ELEMENTAL_MEDIACONNECT': ['AWS Elemental MediaConnect', 'MediaConnect'],
                  'ELEMENTAL_MEDIACONVERT': ['AWS Elemental MediaConvert', 'MediaConvert'],
                  'ELEMENTAL_MEDIALIVE': ['AWS Elemental MediaLive', 'MediaLive'],
                  'ELEMENTAL_MEDIAPACKAGE': ['AWS Elemental MediaPackage', 'MediaPackage'],
                  'ELEMENTAL_MEDIASTORE': ['AWS Elemental MediaStore', 'MediaStore'],
                  'ELEMENTAL_MEDIATAILOR': ['AWS Elemental MediaTailor', 'MediaTailor'],
                  'ELEMENTAL_SERVER': ['AWS Elemental Server', 'Elemental Server'],
                  'INTERACTIVE_VIDEO_SERVICE': ['Amazon Interactive Video Service', 'IVS'],
                  'NIMBLE_STUDIO': ['Amazon Nimble Studio', 'Nimble Studio'],

                  # Migration & Transfer
                  'APPLICATION_DISCOVERY_SERVICE': ['AWS Application Discovery Service', 'ADS'],
                  'APPLICATION_MIGRATION_SERVICE': ['AWS Application Migration Service', 'MGN'],
                  'DATASYNC': ['AWS DataSync', 'DataSync'],
                  'MIGRATION_EVALUATOR': ['AWS Migration Evaluator', 'Migration Evaluator'],
                  'MIGRATION_HUB': ['AWS Migration Hub', 'Migration Hub'],
                  'MIGRATION_HUB_REFACTOR_SPACES': ['AWS Migration Hub Refactor Spaces', 'Refactor Spaces'],
                  'SERVER_MIGRATION_SERVICE': ['AWS Server Migration Service', 'SMS'],
                  'TRANSFER_FAMILY': ['AWS Transfer Family', 'Transfer'],
                  'MAINFRAME_MODERNIZATION': ['AWS Mainframe Modernization', 'Mainframe Modernization'],

                  # Networking & Content Delivery
                  'API_GATEWAY': ['Amazon API Gateway', 'API Gateway', 'APIGateway'],
                  'CLOUDFRONT': ['Amazon CloudFront', 'CloudFront'],
                  'CLOUD_MAP': ['AWS Cloud Map', 'Cloud Map'],
                  'DIRECT_CONNECT': ['AWS Direct Connect', 'Direct Connect', 'DX'],
                  'GLOBAL_ACCELERATOR': ['AWS Global Accelerator', 'Global Accelerator'],
                  'PRIVATE_5G': ['AWS Private 5G', 'Private 5G'],
                  'PRIVATELINK': ['AWS PrivateLink', 'PrivateLink'],
                  'ROUTE_53': ['Amazon Route 53', 'Route 53', 'Route53'],
                  'ROUTE_53_RESOLVER': ['Amazon Route 53 Resolver', 'Route 53 Resolver'],
                  'VPC': ['Amazon Virtual Private Cloud', 'Amazon VPC', 'VPC'],
                  'VPC_LATTICE': ['Amazon VPC Lattice', 'VPC Lattice'],
                  'NETWORK_FIREWALL': ['AWS Network Firewall', 'Network Firewall', 'NetworkFirewall'],
                  'NETWORK_MANAGER': ['AWS Network Manager', 'Network Manager'],
                  'TRANSIT_GATEWAY': ['AWS Transit Gateway', 'Transit Gateway', 'TGW'],
                  'APP_MESH': ['AWS App Mesh', 'App Mesh'],
                  'SITE_TO_SITE_VPN': ['AWS Site-to-Site VPN', 'VPN'],
                  'CLIENT_VPN': ['AWS Client VPN', 'Client VPN'],

                  # Quantum Technologies
                  'BRAKET': ['Amazon Braket', 'Braket'],
                  'QUANTUM_SOLUTIONS_LAB': ['AWS Quantum Solutions Lab', 'Quantum Solutions'],

                  # Robotics
                  'ROBOMAKER': ['AWS RoboMaker', 'RoboMaker'],

                  # Satellite
                  'GROUND_STATION': ['AWS Ground Station', 'Ground Station'],

                  # Security, Identity & Compliance
                  'ARTIFACT': ['AWS Artifact', 'Artifact'],
                  'AUDIT_MANAGER': ['AWS Audit Manager', 'Audit Manager'],
                  'CERTIFICATE_MANAGER': ['AWS Certificate Manager', 'ACM', 'Certificate Manager'],
                  'CLOUDHSM': ['AWS CloudHSM', 'CloudHSM'],
                  'COGNITO': ['Amazon Cognito', 'Cognito'],
                  'DETECTIVE': ['Amazon Detective', 'Detective'],
                  'DIRECTORY_SERVICE': ['AWS Directory Service', 'Directory Service', 'AD Connector'],
                  'FIREWALL_MANAGER': ['AWS Firewall Manager', 'Firewall Manager'],
                  'GUARDDUTY': ['Amazon GuardDuty', 'GuardDuty', 'Guard Duty'],
                  'IAM': ['AWS Identity and Access Management', 'IAM', 'Identity and Access Management'],
                  'IAM_IDENTITY_CENTER': ['AWS IAM Identity Center', 'IAM Identity Center', 'Single Sign-On'],
                  'INSPECTOR': ['Amazon Inspector', 'Inspector'],
                  'INSPECTOR_CLASSIC': ['Amazon Inspector Classic', 'Inspector Classic'],
                  'KMS': ['AWS Key Management Service', 'AWS KMS', 'KMS'],
                  'MACIE': ['Amazon Macie', 'Macie'],
                  'NETWORK_FIREWALL': ['AWS Network Firewall', 'Network Firewall'],
                  'PRIVATE_CERTIFICATE_AUTHORITY': ['AWS Private Certificate Authority', 'Private CA'],
                  'RESOURCE_ACCESS_MANAGER': ['AWS Resource Access Manager', 'RAM'],
                  'SECRETS_MANAGER': ['AWS Secrets Manager', 'Secrets Manager'],
                  'SECURITY_HUB': ['AWS Security Hub', 'Security Hub'],
                  'SHIELD': ['AWS Shield', 'Shield'],
                  'SIGNER': ['AWS Signer', 'Signer'],
                  'VERIFIED_PERMISSIONS': ['Amazon Verified Permissions', 'Verified Permissions'],
                  'WAF': ['AWS WAF', 'WAF', 'Web Application Firewall'],
                  'SECURITY_LAKE': ['Amazon Security Lake', 'Security Lake'],
                  'VERIFIED_ACCESS': ['AWS Verified Access', 'Verified Access'],

                  # Serverless
                  'LAMBDA': ['AWS Lambda', 'Lambda', 'Lambda Function'],
                  'FARGATE': ['AWS Fargate', 'Fargate'],
                  'AURORA_SERVERLESS': ['Amazon Aurora Serverless', 'Aurora Serverless'],
                  'DYNAMODB': ['Amazon DynamoDB', 'DynamoDB'],
                  'API_GATEWAY': ['Amazon API Gateway', 'API Gateway'],
                  'STEP_FUNCTIONS': ['AWS Step Functions', 'Step Functions'],
                  'SAM': ['AWS Serverless Application Model', 'SAM'],
                  'EVENTBRIDGE': ['Amazon EventBridge', 'EventBridge'],
                  'SNS': ['Amazon Simple Notification Service', 'SNS'],
                  'SQS': ['Amazon Simple Queue Service', 'SQS'],
                  'APP_RUNNER': ['AWS App Runner', 'App Runner'],

                  # Storage
                  'S3': ['Amazon Simple Storage Service', 'Amazon S3', 'S3'],
                  'S3_GLACIER': ['Amazon S3 Glacier', 'S3 Glacier', 'Glacier'],
                  'S3_GLACIER_DEEP_ARCHIVE': ['Amazon S3 Glacier Deep Archive', 'Glacier Deep Archive'],
                  'EBS': ['Amazon Elastic Block Store', 'Amazon EBS', 'EBS'],
                  'EFS': ['Amazon Elastic File System', 'Amazon EFS', 'EFS'],
                  'FSX': ['Amazon FSx', 'FSx'],
                  'FSX_LUSTRE': ['Amazon FSx for Lustre', 'FSx Lustre'],
                  'FSX_NETAPP': ['Amazon FSx for NetApp ONTAP', 'FSx NetApp'],
                  'FSX_WINDOWS': ['Amazon FSx for Windows File Server', 'FSx Windows'],
                  'FSX_OPENZFS': ['Amazon FSx for OpenZFS', 'FSx OpenZFS'],
                  'BACKUP': ['AWS Backup', 'Backup'],
                  'ELASTIC_DISASTER_RECOVERY': ['AWS Elastic Disaster Recovery', 'Elastic DR'],
                  'SNOW_FAMILY': ['AWS Snow Family', 'Snow Family'],
                  'SNOWBALL': ['AWS Snowball', 'Snowball'],
                  'SNOWBALL_EDGE': ['AWS Snowball Edge', 'Snowball Edge'],
                  'SNOWCONE': ['AWS Snowcone', 'Snowcone'],
                  'SNOWMOBILE': ['AWS Snowmobile', 'Snowmobile'],
                  'STORAGE_GATEWAY': ['AWS Storage Gateway', 'Storage Gateway'],

                  # VR & AR (Virtual & Augmented Reality)
                  'SUMERIAN': ['Amazon Sumerian', 'Sumerian'],

                  # Additional Services
                  'ANALYZER': ['AWS Analyzer', 'Analyzer'],
                  'BILLING': ['AWS Billing', 'Billing'],
                  'BLOCKCHAIN': ['Amazon Managed Blockchain', 'Blockchain'],
                  'CLOUD_DIRECTORY': ['Amazon Cloud Directory', 'Cloud Directory'],
                  'CODESTAR': ['AWS CodeStar', 'CodeStar'],
                  'DATA_LIFECYCLE_MANAGER': ['Amazon Data Lifecycle Manager', 'DLM'],
                  'DEVICE_FARM': ['AWS Device Farm', 'Device Farm'],
                  'IMPORT_EXPORT': ['AWS Import/Export', 'Import/Export'],
                  'IOT_THINGS_GRAPH': ['AWS IoT Things Graph', 'Things Graph'],
                  'MANAGED_SERVICES': ['AWS Managed Services', 'AMS'],
                  'MARKETPLACE': ['AWS Marketplace', 'Marketplace'],
                  'QUICKSIGHT': ['Amazon QuickSight', 'QuickSight'],
                  'RAM': ['AWS Resource Access Manager', 'RAM'],
                  'SERVICE_QUOTAS': ['Service Quotas'],
                  'SHIELD_ADVANCED': ['AWS Shield Advanced', 'Shield Advanced'],
                  'SUPPORT': ['AWS Support', 'Support'],
                  'SYSTEMS_MANAGER_SESSION_MANAGER': ['AWS Systems Manager Session Manager', 'Session Manager'],
                  'TAG_EDITOR': ['AWS Tag Editor', 'Tag Editor'],
                  'TRUSTED_ADVISOR': ['AWS Trusted Advisor', 'Trusted Advisor'],
                  'WAF_REGIONAL': ['AWS WAF Regional', 'WAF Regional']
                  }

          def match_service_names(service_input: str, service_mapping: Dict) -> List[str]:
              """
              Match input service name against the mapping and return all possible matches
              """
              matched_services = set()
              service_input = service_input.upper().strip()
              
              for key, variants in service_mapping.items():
                  # Check if input matches any variant
                  if any(service_input in variant.upper() for variant in variants):
                      matched_services.update(variants)
                  # Check if input is a partial match
                  elif any(re.search(service_input, variant.upper()) for variant in variants):
                      matched_services.update(variants)
              
              return list(matched_services)


          def validate_date_boundaries(start, end, is_forecast=False):
              """
              Validate date range without forcing month boundaries and adjust current month end date.
              For forecasting requests, allow future dates.
              """
              
              # If end date is the first day of a month, look at the previous day to determine the actual month we're analyzing
              actual_end = end - timedelta(days=1) if end.day == 1 else end
              
              # Check if actual end date is in current month
              today = datetime.now()
              
              # For historical cost analysis (non-forecast requests)
              if not is_forecast:
                  if (actual_end.year == today.year and 
                      actual_end.month == today.month and 
                      actual_end > today):
                      end = today + timedelta(days=1)  # Add one day to make it inclusive
                      
                  # Validate that end date is not beyond next month for historical data
                  next_month = (today.replace(day=1) + timedelta(days=32)).replace(day=1)
                  if end > next_month:
                      raise ValueError("End date cannot be beyond the beginning of next month for historical cost analysis")
              else:
                  # For forecast requests
                  # AWS Cost Explorer typically allows forecasting up to 12 months into the future
                  max_forecast_date = today + timedelta(days=365)
                  if end > max_forecast_date:
                      raise ValueError("Forecast period cannot exceed 12 months into the future")
                  
                  # Ensure start date is not in the past for forecasts
                  if start < today:
                      start = today
                      
              return start, end

          def get_group_by_type(group_by_input):
              """
              Map various input formats to correct group by types
              """
              if not group_by_input:
                  return 'SERVICE'  # Default

              group_by_input = str(group_by_input).upper().replace(' ', '_')
              
              group_by_mapping = {
                  # Service mappings
                  'SERVICE': 'SERVICE',
                  'SERVICES': 'SERVICE',
                  'BY_SERVICE': 'SERVICE',
                  
                  # Usage type mappings
                  'USAGE': 'USAGE_TYPE',
                  'USAGE_TYPE': 'USAGE_TYPE',
                  'USAGETYPE': 'USAGE_TYPE',
                  'BY_USAGE': 'USAGE_TYPE',
                  'BY_USAGE_TYPE': 'USAGE_TYPE',
                  
                  # Linked account mappings
                  'ACCOUNT': 'LINKED_ACCOUNT',
                  'ACCOUNTS': 'LINKED_ACCOUNT',
                  'LINKED_ACCOUNT': 'LINKED_ACCOUNT',
                  'LINKEDACCOUNT': 'LINKED_ACCOUNT',
                  'BY_ACCOUNT': 'LINKED_ACCOUNT',
                  'BY_LINKED_ACCOUNT': 'LINKED_ACCOUNT',
                  'LINKED_ACCOUNTS': 'LINKED_ACCOUNT',
                  
                  # Region mappings
                  'REGION': 'REGION',
                  'REGIONS': 'REGION',
                  'BY_REGION': 'REGION',
                  
                  # Billing entity mappings
                  'BILLING': 'BILL_BILLING_ENTITY',
                  'BILLING_ENTITY': 'BILL_BILLING_ENTITY',
                  'BILLINGENTITY': 'BILL_BILLING_ENTITY',
                  'BY_BILLING': 'BILL_BILLING_ENTITY',
                  'BY_BILLING_ENTITY': 'BILL_BILLING_ENTITY'
              }
              
              return group_by_mapping.get(group_by_input, 'SERVICE')

          def format_response(status_code, body, action_group="", api_path=""):
              """Format the API response."""
              response = {
                  "messageVersion": "1.0",
                  "response": {
                      "actionGroup": action_group,
                      "apiPath": api_path,
                      "httpMethod": "POST",
                      "httpStatusCode": status_code,
                      "responseBody": {
                          "application/json": {
                              "body": body
                          }
                      }
                  }
              }
              print("Formatted response:", json.dumps(response))
              return response

          def get_cost_forecast(start_date: datetime, 
                              end_date: datetime, 
                              services: Union[str, List[str]] = None,
                              granularity: str = 'MONTHLY',
                              api_path='',
                              action_group: str = '') -> Dict:
              """
              Get cost forecast from current date to specified end date
              
              Args:
                  start_date (datetime): Start date (will be adjusted to current date)
                  end_date (datetime): End date for forecast
                  services (Union[str, List[str]], optional): Specific AWS service(s) to forecast. Defaults to None.
                  granularity (str, optional): Time granularity (MONTHLY/DAILY). Defaults to 'MONTHLY'.
              
              Returns:
                  Dict: Formatted response with forecast data or error message
              """
              print(f"get_cost_forecast called with action_group: '{action_group}'")  # Debug logging
              try:
                  print(f"get_cost_forecast called with action_group: '{action_group}'")  # Debug logging
                  client = boto3.client('ce')
                  
                  # Always use current date as start date for forecasting
                  current_date = datetime.now()
                  
                  # Store dates for display
                  display_start_date = current_date.strftime('%Y-%m-%d')
                  display_end_date = end_date.strftime('%Y-%m-%d')
                  
                  # Validate granularity
                  valid_granularities = ['MONTHLY', 'DAILY']
                  if granularity not in valid_granularities:
                      return format_response(400, {
                          "message": f"Invalid granularity. Must be one of: {', '.join(valid_granularities)}",
                          "provided": granularity
                      }, action_group, f"{api_path}") 

                  # Prepare filters if specific services are requested
                  filters = None
                  if services:
                      # Convert single service to list
                      if isinstance(services, str):
                          # Split by comma and clean up each service
                          services_list = [service.strip() for service in services.split(',')]
                          services = services_list
                      
                      print("all services:", services)

                      # Get service mapping and match services
                      service_mapping = get_aws_service_mapping()  # Ensure this function exists in your code
                      matched_services = set()
                      
                      for service in services:
                          matched = match_service_names(service, service_mapping)  # Ensure this function exists
                          matched_services.update(matched)
                      
                      if not matched_services:
                          return format_response(400, {
                              "message": f"No matching AWS services found for: {', '.join(services)}",
                              "suggestions": "Please try with a valid AWS service name"
                          }, action_group, f"{api_path}") 
                      
                      filters = {
                          'Dimensions': {
                              'Key': 'SERVICE',
                              'Values': list(matched_services)
                          }
                      }

                  # Prepare API request parameters
                  kwargs = {
                      'TimePeriod': {
                          'Start': current_date.strftime('%Y-%m-%d'),
                          'End': end_date.strftime('%Y-%m-%d')
                      },
                      'Metric': 'UNBLENDED_COST',
                      'Granularity': granularity,
                      'PredictionIntervalLevel': 85  # Confidence level for the forecast
                  }
                  
                  if filters:
                      kwargs['Filter'] = filters

                  try:
                      forecast_response = client.get_cost_forecast(**kwargs)
                      
                      # Process forecast data
                      total_forecast = Decimal(forecast_response.get('Total', {}).get('Amount', '0'))
                      
                      # Process forecast results by time period
                      total_forecast = Decimal('0')
                      period_forecast = Decimal('0')
                      forecast_results = []
                      for point in forecast_response.get('ForecastResultsByTime', []):
                          point_start = datetime.strptime(point['TimePeriod']['Start'], '%Y-%m-%d')
                          point_end = datetime.strptime(point['TimePeriod']['End'], '%Y-%m-%d')
                          point_amount = Decimal(point['MeanValue'])
                          
                          # Add to total forecast
                          total_forecast += point_amount
                          
                          # Check if this point falls within requested period
                          if (point_start >= start_date and point_start < end_date):
                              period_forecast += point_amount
                          forecast_results.append({
                              'time_period': {
                                  'start': point['TimePeriod']['Start'],
                                  'end': point['TimePeriod']['End']
                              },
                              'forecast_amount': {
                                  'amount': str(point_amount.quantize(Decimal('0.01'))),
                                  'unit': 'USD'
                              },
                              'prediction_interval': {
                                  'lower': str(Decimal(point.get('PredictionIntervalLowerBound', '0')).quantize(Decimal('0.01'))),
                                  'upper': str(Decimal(point.get('PredictionIntervalUpperBound', '0')).quantize(Decimal('0.01'))),
                                  'level': 85
                              }
                          })
                      
                      response = format_response(200, {
                          "message": f"Cost forecast analysis for period {display_start_date} to {display_end_date}",
                          "period": {
                              "start": display_start_date,
                              "end": display_end_date
                          },
                          "requested_period_forecast": {
                              "amount": str(period_forecast.quantize(Decimal('0.01'))),
                              "unit": "USD"
                          },
                          "total_forecast": {
                              "amount": str(total_forecast.quantize(Decimal('0.01'))),
                              "unit": "USD"
                          },
                          "granularity": granularity,
                          "forecast_by_period": forecast_results,
                          "services_included": list(matched_services) if services else ["All Services"],
                          "metadata": {
                              "prediction_interval_level": 85,
                              "estimated_total_lower": str(Decimal(forecast_response.get('Total', {})
                                  .get('PredictionIntervalLowerBound', '0')).quantize(Decimal('0.01'))),
                              "estimated_total_upper": str(Decimal(forecast_response.get('Total', {})
                                  .get('PredictionIntervalUpperBound', '0')).quantize(Decimal('0.01')))
                          }
                      }, action_group, f"{api_path}") 

                      print(f"Final forecast response: {json.dumps(response)}")  # Debug logging
                      return response

                  except client.exceptions.DataUnavailableException:
                      return format_response(400, {
                          "message": "Forecast data is not available for the specified time period",
                          "period": {
                              "start": display_start_date,
                              "end": display_end_date
                          },
                          "suggestion": "Try a shorter forecast period or check if you have sufficient historical data"
                      }, action_group, "/get_cost_and_usage")
                  
                  except client.exceptions.InvalidNextTokenException:
                      return format_response(400, {
                          "message": "Invalid pagination token",
                          "period": {
                              "start": display_start_date,
                              "end": display_end_date
                          }
                  }, action_group, f"{api_path}") 
                      
                  except client.exceptions.RequestChangedException:
                      return format_response(400, {
                          "message": "Request was changed during pagination",
                          "period": {
                              "start": display_start_date,
                              "end": display_end_date
                          }
                      }, action_group, f"{api_path}") 
                      
              except Exception as e:
                  print(f"Error in get_cost_forecast: {str(e)}")
                  print("Traceback:", traceback.format_exc())
                  return format_response(500, {
                      "message": f"Error processing forecast request: {str(e)}",
                      "period": {
                          "start": display_start_date,
                          "end": display_end_date
                      }
                  }, action_group, f"{api_path}") 


          def lambda_handler(event, context):
              """Main Lambda handler."""
              try:
                  print("Received event:", json.dumps(event))
                  
                  agent = event.get('agent', {})
                  action_group = event.get('actionGroup', '')
                  print(f"Extracted actionGroup: '{action_group}'")  # Debug logging
                  api_path = event.get('apiPath', '')

                  function = event.get('apiPath', '').lstrip('/')
                  
                  # Extract parameters
                  parameters_dict = {}
                  if 'parameters' in event:
                      for param in event['parameters']:
                          parameters_dict[param['name']] = param['value']
                  
                  start_date = parameters_dict.get('start_date')
                  end_date = parameters_dict.get('end_date')

                  # if date in "mm/dd/yyyy" format then convert it to "yyyy-mm-dd"
                  if start_date and '/' in start_date and len(start_date.split('/')) == 3:
                      start_date = datetime.strptime(start_date, '%m/%d/%Y').strftime('%Y-%m-%d')
                      print("start_date:", start_date)  # Add this log
                  if end_date and '/' in end_date and len(end_date.split('/')) == 3:
                      end_date = datetime.strptime(end_date, '%m/%d/%Y').strftime('%Y-%m-%d')
                      print("end_date:", end_date)      # Add this log

                  print("Received start_date:", start_date)  # Add this log
                  print("Received end_date:", end_date)      # Add this log
                  
                  # Get the input text from the event
                  #request_text = event.get('inputText', '') 
                  
                  # Normalize dates for comparison
                  current_date = datetime.now()
                  current_date_normalized = datetime(current_date.year, current_date.month, current_date.day)

                  end_date_format = datetime.strptime(end_date, '%Y-%m-%d')
                  end_date_normalized = datetime(end_date_format.year, end_date_format.month, end_date_format.day)

                  if end_date_normalized > current_date_normalized:
                      is_forecast = True
                  else:
                      is_forecast = False
                      return format_response(400, f"This is not a forecast request. The end-date is not a future date. Please check", 
                                              action_group, f"/{function}")
                  
                  print("Is forecast request:", is_forecast)  # Add this log

                  # Passing the actual date back from the function
                  display_start_date = start_date
                  display_end_date = end_date
                  
                  # Get and normalize group_by parameter
                  group_by_input = parameters_dict.get('group_by', '')
                  group_by = get_group_by_type(group_by_input)
                  
                  granularity = parameters_dict.get('granularity', 'MONTHLY')
                  
                  # Handle dates
                  if not start_date and not end_date:
                      end = datetime.now()
                      start = end - timedelta(days=365)
                  else:
                      try:
                          if end_date:
                              end = datetime.strptime(end_date, '%Y-%m-%d') + timedelta(days=1)
                          else:
                              end = datetime.now()
                          
                          if start_date:
                              start = datetime.strptime(start_date, '%Y-%m-%d')
                          else:
                              start = end - timedelta(days=365)
                      except ValueError as e:
                          return format_response(400, f"Invalid date format. Use YYYY-MM-DD. Error: {str(e)}", 
                                              action_group, f"/{function}")
                  
                  # If it's a forecast request, handle it differently
                  if is_forecast:
                      try:
                          print(f"get_cost_forecast calling with action_group 1: '{action_group}'")  # Debug logging
                          
                          # Get current date for comparison
                          current_date = datetime.now()
                          
                          # Calculate max forecast date from current date
                          max_forecast_date = current_date + timedelta(days=365)
                          
                          # Normalize dates by removing time component for comparison
                          end_normalized = end.replace(hour=0, minute=0, second=0, microsecond=0)
                          max_forecast_normalized = max_forecast_date.replace(hour=0, minute=0, second=0, microsecond=0)
                          
                          # Debug logging after normalization
                          print(f"End date (normalized): '{end_normalized}'")
                          print(f"Max forecast date (normalized): '{max_forecast_normalized}'")
                          print(f"Comparison result: {end_normalized > max_forecast_normalized}")
                          
                          if end_normalized > max_forecast_normalized:
                              print(f"Entered max forecast condition. Date exceeds: '{max_forecast_normalized}'")  # Debug logging
                              return format_response(400, {
                                  "message": "Forecast period cannot exceed 12 months into the future",
                                  "period": {
                                      "start": display_start_date,
                                      "end": display_end_date
                                  },
                                  "maximum_allowed_date": max_forecast_normalized.strftime('%Y-%m-%d')
                              }, action_group, f"/{function}")
                          else:
                              services = parameters_dict.get('services', None)
                              print(f"get_cost_forecast calling with action_group: '{action_group}'")  # Debug logging
                              return get_cost_forecast(
                                  start_date=start,
                                  end_date=end,
                                  services=services,
                                  granularity='MONTHLY',
                                  api_path=api_path,
                                  action_group=action_group
                              )

                      except Exception as e:
                          print(f"Error in forecast request: {str(e)}")
                          return format_response(500, f"Error processing forecast request: {str(e)}", 
                                              action_group, f"/{function}")

                  # Validate and adjust date boundaries based on whether it's a forecast request
                  try:
                      start, end = validate_date_boundaries(start, end, is_forecast=False)
                  except ValueError as ve:
                      return format_response(400, {
                          "message": str(ve),
                          "period": {
                              "start": display_start_date,
                              "end": display_end_date
                          }
                      }, action_group, f"/{function}")

                  print("endDate:", end)

              except Exception as e:
                  print(f"Unexpected error in lambda_handler: {str(e)}")
                  print("Traceback:", traceback.format_exc())
                  return format_response(500, f"Unexpected error: {str(e)}", 
                                      event.get('actionGroup', ''), event.get('apiPath', ''))
          
      Description: 'Lambda function to get cost forecast from cost explorer'
      Timeout: 900
      MemorySize: 1024

  # Lambda Function 5: ClockandCalendar
  ClockandCalendar:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ClockandCalendar
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: nodejs20.x
      Code:
        ZipFile: |          
          const get_current_time = (timezone) => {
            const options = {
                timeZone: timezone,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                timeZoneName: 'short'
            };
            const formattedTime = new Date().toLocaleString('en-US', options);
            return formattedTime;
          };
          const get_parameter_by_name = (parameters_list, name) => {
            const result = parameters_list.find(obj => obj.name === name);
            return result || {value: 'UTC'}; // Return null if the object is not found
          }
          module.exports.handler = async (event) => {
              console.log('event:', event);
              // Structure of the response for the Bedrock Agent
              let action_response = {
                  messageVersion: "1.0",
                  response: {
                      actionGroup: event.actionGroup,
                      function: event.function,
                      functionResponse: {
                          responseBody: {
                              TEXT: {
                                  body: '',
                              }
                          }
                      },
                  }
              }

              try {
                  // Get the current time in the specified timezone
                  const currentTime = get_current_time(get_parameter_by_name(event.parameters || [],'timezone').value);
                  action_response.response.functionResponse.responseBody.TEXT.body = JSON.stringify({
                      date: {current_date_time: currentTime},
                      description: `This is the current date and time in the specified timezone, if no timezone was passed, the default one is UTC. The format used us MM/DD/YYYY HH:MM:SS AM/PM TIMEZONE_NAME`
                  })
                  // Return the response in a way that Bedrock agent will understand it
                  console.log('return: ', JSON.stringify(action_response, null, 2));
                  return action_response;

              } catch (error) {
                  // Corrected error response structure
                  action_response.response.functionResponse.responseBody.TEXT.body = JSON.stringify({
                      error: error.message
                  });
                  return action_response;
              }
          };
      Description: 'Lambda function for ClockandCalendar using Python'
      Timeout: 100
      MemorySize: 128
  
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: CognitoUserPoolforFinOpsApp
      UsernameAttributes: []  
      UsernameConfiguration: 
        CaseSensitive: false
      AliasAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: false
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: true
        InviteMessageTemplate:
          EmailMessage: "Your username is {username}, your temporary password is {####} and you'll be asked to change it at first login."
          EmailSubject: "Your FinOps Agent App temporary password"
      AutoVerifiedAttributes:
        - email
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT
      UserPoolAddOns:
        AdvancedSecurityMode: ENFORCED

  FinanceGroup:
    Type: AWS::Cognito::UserPoolGroup
    DependsOn: CognitoUserPool
    Properties:
      GroupName: Finance
      UserPoolId: !Ref CognitoUserPool

  FinOpsUser:
    Type: AWS::Cognito::UserPoolUser
    DependsOn: FinanceGroup
    Properties:
      UserPoolId: !Ref CognitoUserPool
      Username: !Select [0, !Split ["@", !Ref UserEmail]]
      UserAttributes:
        - Name: email
          Value: !Ref UserEmail
      DesiredDeliveryMediums:
        - EMAIL
  
  FinOpsUserGroupAttachment:
    Type: AWS::Cognito::UserPoolUserToGroupAttachment
    DependsOn: FinOpsUser
    Properties:
      GroupName: !Ref FinanceGroup
      Username: !Select [0, !Split ["@", !Ref UserEmail]]
      UserPoolId: !Ref CognitoUserPool

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: FinOpsApp
      UserPoolId: !Ref CognitoUserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_PASSWORD_AUTH

  CognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    DependsOn: UserPoolClient
    Properties:
      IdentityPoolName: cognito-identity-pool-finops
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders: 
        - ClientId: !Ref UserPoolClient
          ProviderName: !GetAtt CognitoUserPool.ProviderName


  # CognitoIdentityPoolRole:
  #   Type: AWS::IAM::Role
  #   DependsOn: CognitoIdentityPoolBedrockAccessPolicy
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: '2012-10-17'
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Federated: cognito-identity.amazonaws.com
  #           Action: sts:AssumeRoleWithWebIdentity
  #           Condition:
  #             StringEquals: 
  #               'cognito-identity.amazonaws.com:aud': !Ref CognitoIdentityPool
  #             'ForAnyValue:StringLike':
  #               'cognito-identity.amazonaws.com:amr': authenticated
  #               'cognito-identity.amazonaws.com:groups': Finance
  #     ManagedPolicyArns:
  #       - !Ref CognitoIdentityPoolBedrockAccessPolicy
  #     Policies:
  #       - PolicyName: cognito-identity-pool-iam-role
  #         PolicyDocument:
  #           Version: '2012-10-17'
  #           Statement:
  #             - Effect: Allow
  #               Action:
  #                 - 'mobileanalytics:PutEvents'
  #                 - 'cognito-sync:*'
  #                 - 'cognito-identity:*'
  #               Resource: '*'
  
  CognitoIdentityPoolRoleAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    DependsOn: 
      - FinanceRestrictedRole
      - DefaultAuthenticatedRole
      - FinOpsUserGroupAttachment
      - CognitoUserPool
      - UserPoolClient
      - CognitoIdentityPool
    Properties:
      IdentityPoolId: !Ref CognitoIdentityPool
      Roles:
        authenticated: !GetAtt DefaultAuthenticatedRole.Arn
      RoleMappings:
        cognitoidp:
          Type: Rules
          AmbiguousRoleResolution: AuthenticatedRole
          IdentityProvider: !Join ["", [
            "cognito-idp.", 
            !Ref "AWS::Region", 
            ".amazonaws.com/", 
            !Ref CognitoUserPool,
            ":",
            !Ref UserPoolClient
          ]]
          RulesConfiguration:
            Rules:
              - Claim: "cognito:groups"
                MatchType: Contains
                Value: "Finance"
                RoleARN: !GetAtt FinanceRestrictedRole.Arn

  FinanceRestrictedRole:
    Type: AWS::IAM::Role
    DependsOn: CognitoIdentityPoolBedrockAccessPolicy
    Properties:
      RoleName: FinanceUserRestrictedRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
            Action: sts:AssumeRoleWithWebIdentity
            Condition:
              StringEquals: 
                'cognito-identity.amazonaws.com:aud': !Ref CognitoIdentityPool
              'ForAnyValue:StringLike':
                'cognito-identity.amazonaws.com:amr': authenticated
  #              'cognito-identity.amazonaws.com:groups': Finance                -- Not working
      ManagedPolicyArns:
        - !Ref CognitoIdentityPoolBedrockAccessPolicy
  #      - !Ref RestrictSTSOperationsPolicy
        - !Ref DefaultAuthenticatedPolicy
        # Policies:
        #   - PolicyName: RestrictSTSOperations
        #     PolicyDocument:
        #       Version: '2012-10-17'
        #       Statement:
        #         - Effect: Deny
        #           Action:
        #             - 'sts:AssumeRole'
        #             - 'sts:AssumeRoleWithSAML'
        #             - 'sts:GetFederationToken'
        #             - 'sts:GetSessionToken'
        #           Resource: '*'
        #         - Effect: Allow
        #           Action:
        #             - 'mobileanalytics:PutEvents'
        #             - 'cognito-sync:*'
        #             - 'cognito-identity:*'
        #           Resource: '*'
  
  DefaultAuthenticatedRole:
    Type: AWS::IAM::Role
    DependsOn: CognitoIdentityPoolBedrockAccessPolicy
    Properties:
      RoleName: DefaultCognitoAuthenticatedRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
            Action: sts:AssumeRoleWithWebIdentity
            Condition:
              StringEquals: 
                'cognito-identity.amazonaws.com:aud': !Ref CognitoIdentityPool
              'ForAnyValue:StringLike':
                'cognito-identity.amazonaws.com:amr': authenticated
      ManagedPolicyArns:
        - !Ref DefaultAuthenticatedPolicy
      # Policies:
      #   - PolicyName: DefaultAuthenticatedUserPolicy
      #     PolicyDocument:
      #       Version: '2012-10-17'
      #       Statement:
      #         - Effect: Allow
      #           Action:
      #             - 'mobileanalytics:PutEvents'
      #             - 'cognito-sync:*'
      #             - 'cognito-identity:*'
      #           Resource: '*'
  
  CognitoIdentityPoolBedrockAccessPolicy:
    Type: AWS::IAM::ManagedPolicy
    DependsOn: CognitoIdentityPool
    Properties:
      ManagedPolicyName: Finance-BedrockAccess
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: 
              - bedrock:InvokeAgent
              - bedrock:ListAgents
              - bedrock:GetAgent              
            Resource: 
              - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/${SupervisorAgent}/TSTALIASID      
      
  DefaultAuthenticatedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: Default-CognitoAccess
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'mobileanalytics:PutEvents'
              - 'cognito-sync:*'
              - 'cognito-identity:*'
            Resource: '*'

  RestrictSTSOperationsPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: Restrict-STSOperations
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Deny
            Action:
              - 'sts:AssumeRole'
              - 'sts:AssumeRoleWithSAML'
              - 'sts:GetFederationToken'
              - 'sts:GetSessionToken'
            Resource: '*'

Outputs:
  UserPoolId:
    Description: Amazon Cognito User Pool ID 
    Value: !Ref CognitoUserPool
  UserPoolClientId:
    Description: Amazon Cognito User Pool Client ID
    Value: !Ref UserPoolClient
  IdentityPoolId:
    Description: Amazon Cognito Identity Pool ID
    Value: !Ref CognitoIdentityPool
  BedrockAgentName:
    Description: Amazon Bedrock Agent Name
    Value: FinOpsAgent
  BedrockAgentId:
    Description: Amazon Bedrock Agent ID
    Value: !Ref SupervisorAgent
  BedrockAgentAliasId:
    Description: Amazon Bedrock Agent Alias ID
    Value: TSTALIASID
  AWSRegion:
    Description: AWS Region
    Value: !Ref 'AWS::Region'
  Username:
    Description: Username for a FinOps User
    Value: !Select [0, !Split ["@", !Ref UserEmail]]